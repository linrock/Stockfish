/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2024 The Stockfish developers (see AUTHORS file)

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "search.h"

#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <initializer_list>
#include <string>
#include <utility>

#include "evaluate.h"
#include "misc.h"
#include "movegen.h"
#include "movepick.h"
#include "nnue/network.h"
#include "nnue/nnue_accumulator.h"
#include "nnue/nnue_common.h"
#include "nnue/nnue_misc.h"
#include "position.h"
#include "syzygy/tbprobe.h"
#include "thread.h"
#include "timeman.h"
#include "tt.h"
#include "types.h"
#include "uci.h"
#include "ucioption.h"

namespace Stockfish {

namespace TB = Tablebases;

using Eval::evaluate;
using namespace Search;

namespace {

static constexpr double EvalLevel[10] = {0.981, 0.956, 0.895, 0.949, 0.913,
                                         0.942, 0.933, 0.890, 0.984, 0.941};


int twoW[8][32][30] = {
  {
    {8, 2, -6, -5, 1, -20, -12, 1, -14, -3, 2, -2, -13, 0, -10, 20, -4, 20, 28, 46, -4, -14, 20, -18, 9, -46, -15, -85, 20, 11},
    {-7, -16, 1, 8, 7, 30, 22, 4, 2, -13, 1, -72, -1, 8, -13, 34, 14, -3, -6, -29, 3, -18, -73, -22, 8, -24, -26, -14, -106, -22},
    {13, 30, 2, 21, -5, -59, 2, -31, -1, 10, 2, 54, 6, -7, 10, 22, 31, -2, 8, -52, 6, 8, 29, 0, 20, 40, -25, 11, -48, 51},
    {13, -1, -17, -13, 4, 3, -7, -2, -17, -1, 1, -43, -2, 11, -11, -46, -29, 19, 14, -60, 18, 45, -9, -25, -28, -27, -61, 6, 27, -21},
    {0, 13, 12, 9, -1, -20, 10, -2, -21, -3, -7, 4, 12, -4, -3, 17, 20, 12, 11, 1, -20, -15, -4, -5, 3, 19, 29, 0, 5, 4},
    {-12, -4, -15, -4, 0, -47, -26, -1, 14, 0, 3, -52, -1, 10, 6, -39, -2, -3, -10, 64, 22, 28, -81, 36, 2, -19, 19, 41, -46, -33},
    {-66, -3, 23, 1, 2, 45, 16, -14, 4, -4, 12, 1, 4, 8, -2, -91, -8, -49, -9, -26, 15, -23, -41, -41, 37, -36, -42, -24, -59, 51},
    {-48, -9, 10, -18, -3, 38, -3, 5, -5, -7, 1, -18, 7, -13, 11, 15, -30, -2, -8, 68, 5, 4, -15, -31, 22, 5, 35, 22, 42, -5},
    {-34, 14, 6, -19, -1, -32, 4, 8, 19, 0, -3, -10, 12, 7, 19, 0, 14, -66, 9, 13, 13, -9, 1, 8, -12, -26, -11, -7, -63, -20},
    {-64, -16, 54, -51, -45, -15, 13, 69, 40, -35, -15, -3, 0, 12, 3, -74, -54, 71, -89, 22, -8, -73, -127, 67, -22, 3, 37, 71, -114, -34},
    {-7, 1, 2, 4, -3, 38, 8, 27, 21, 1, -6, 12, -4, 2, -1, -15, -6, 71, -27, -3, -30, -43, 34, 7, -11, 26, -11, -14, -14, -6},
    {-5, -17, 8, 2, 3, -2, -3, 9, 8, -1, -4, -27, -27, 3, 1, 25, -25, 6, 21, -19, 13, 13, 37, -5, 4, 2, 20, -20, -111, -2},
    {-18, -9, -35, -29, 0, 5, -35, -6, 4, -5, 14, -21, -22, 12, -11, 24, -28, 11, -18, -48, 20, 15, -36, 16, 17, -38, 22, -20, -127, 6},
    {17, 5, -13, -9, -2, 15, -24, 6, -20, 4, -4, -16, 9, 6, -1, -5, -1, 0, 18, -14, -6, 35, 50, -5, -127, -65, -9, 51, 24, -127},
    {-13, 8, 13, -6, -4, 16, 16, 13, 10, 10, 1, -23, 7, -4, -8, 36, -8, 8, 12, 46, 3, 11, 14, -5, -127, -29, 12, 72, 22, -127},
    {-4, 1, 9, -6, 0, 24, 10, -10, -2, -5, 2, 2, -4, 1, 2, 29, -9, -16, -4, 25, 2, 11, 9, -2, -127, -127, -11, 89, 31, -127},
    {-12, 10, -1, 14, 3, -36, 12, -3, -11, 1, 1, 13, 16, 1, 0, 22, 26, -31, 18, -33, -1, -4, 9, -10, -2, -1, 0, -5, -33, -12},
    {21, 7, 9, 2, -2, -17, -2, 1, -4, 3, -3, 23, 1, 1, 2, -4, 19, 6, 11, 1, -4, 3, 39, 4, -5, -7, 11, -28, 5, 12},
    {23, 7, -27, -12, -2, 9, 24, 7, -29, 8, -7, 7, 17, -14, -2, -9, 1, 3, 25, 21, -1, 55, 66, 5, -5, 8, -16, 9, -31, -14},
    {-12, 6, 2, -2, 5, -22, -11, -6, -45, -1, -1, -13, 5, -5, -5, 11, 0, 4, 17, -33, 2, 5, 49, 33, -5, 32, 14, 15, -127, 45},
    {13, 53, 62, 41, 10, -6, 45, -11, -30, 19, -30, -66, -11, -6, 16, -14, 65, -22, 53, -12, -53, -4, -105, -91, -65, 44, 28, 8, -24, 2},
    {-8, 0, 2, -9, -5, 28, 8, -4, 6, 1, 2, -3, 2, 0, -3, 32, 0, 54, -2, 72, 2, 9, 38, -4, -107, -109, -18, 82, -11, -127},
    {43, 2, 10, 3, -2, 17, 12, 2, -4, 5, -8, -12, 2, -17, -2, -41, -5, -4, -2, 3, 0, -11, -1, 3, -88, -92, -20, 44, 12, -112},
    {-17, 15, 17, -4, -4, 10, 31, 11, -1, 0, -6, -57, -24, 4, 13, 32, 19, 9, 29, -9, -14, -16, 29, -9, -3, -2, -9, 1, -85, 4},
    {0, 5, 17, 12, 0, 31, 18, 2, -13, 3, -5, -5, -2, 2, 0, 2, 14, -98, 15, 16, -20, -13, 20, -15, -12, 11, 28, -11, 57, 15},
    {-20, -8, 1, 16, 4, -27, -3, 4, 1, 1, -3, 17, 40, -1, 8, 11, -16, -28, 9, -38, 9, -16, 23, -4, -7, -15, 3, -7, -86, -15},
    {-19, -18, 38, -1, -1, 3, -12, 3, 4, 0, 6, -64, 17, 0, -7, 27, -33, -3, -24, -69, -4, -13, -16, -1, 19, -25, -20, 2, -72, -2},
    {-16, 1, 8, -22, 0, -16, 1, 2, -37, -1, 1, -69, 14, -4, -7, -3, -3, -5, 18, -17, 5, 5, 55, 43, -4, -10, 6, 23, -69, 12},
    {24, 5, -1, 2, 1, -13, 47, -3, 13, -3, -2, -38, -11, -1, 0, -29, -5, -4, 1, 33, -4, -38, 22, -22, 0, -56, 17, -19, 24, -28},
    {20, 9, 15, 7, -2, 24, 42, 8, -38, -3, -8, 29, 12, -19, -5, -37, -1, -5, 27, -16, -34, -18, -117, -41, 11, 13, -15, 29, -6, 9},
    {-7, -7, -6, 13, 7, -25, -13, -6, -8, -4, 4, 12, -1, -6, 4, 31, 7, -42, -7, -43, 6, 23, -5, -12, -127, -127, -10, 86, 43, -127},
    {11, 25, -3, 7, -6, -22, 28, -14, -15, 0, -16, -36, -9, -2, -11, 9, 21, 27, -14, 9, -10, -7, -23, -25, -2, 18, 10, -21, 16, 27},
  },
  {
    {-19, -5, -2, 13, -13, -1, 5, 17, -5, 32, 11, -27, -6, 4, -18, -21, 20, 42, 19, 7, 5, -9, -4, 28, -8, -22, 47, -4, 6, 6},
    {-83, 81, 11, -110, 50, 64, -41, -81, -11, -49, -19, 27, -71, -7, 45, 127, 29, -90, -5, 12, -16, 64, -11, -114, -11, 95, -42, 48, 0, 41},
    {33, 68, 18, -30, 60, -59, 9, -33, -3, -24, -23, -5, -65, -36, 42, 16, 5, -26, -5, 14, 53, 108, -12, -49, -16, 104, 21, 48, -4, 31},
    {15, -9, -4, 16, -9, 16, 5, -8, 4, -8, -2, -6, -15, -6, 7, -55, 24, 12, -23, 0, 1, 32, -6, -2, -5, -3, 6, 8, 27, 3},
    {-41, -11, 3, -18, -3, 29, 4, 20, 10, 7, 9, 41, 30, -4, -12, 51, -11, -26, 0, -36, 1, -18, 2, -33, 3, -18, -1, -7, 5, 6},
    {13, -6, -28, -3, -40, -6, 0, 0, -23, 47, -8, -2, 38, -2, -40, 18, 6, 102, -14, -46, -24, 10, 9, 77, -22, -11, -17, -24, 9, 19},
    {53, 1, 3, 19, 13, 3, -16, -10, -12, -30, -18, 6, 0, -4, 17, -94, 10, -118, -63, -1, -12, 58, -77, -23, 61, 25, 12, -61, 5, -2},
    {11, 15, 0, 22, 22, 35, 6, -21, -2, -11, 1, 15, -23, 2, -7, 24, 29, -113, -34, 4, -35, 1, -2, -5, -15, -1, -6, 23, -9, 23},
    {-2, -9, -8, -108, 2, -14, 14, -34, -13, -4, 29, -36, -14, -18, 13, 40, 43, -93, 46, 5, -9, 24, -5, -80, -14, -48, 54, 12, -77, -15},
    {-6, 8, 0, -69, 9, -20, 0, -23, 2, 10, -17, 10, -7, -3, -8, -127, -19, -90, 35, 2, 24, 15, 1, 3, -15, 2, 5, 12, -119, 1},
    {7, -5, 1, -41, 26, 11, 1, -3, 14, -24, 1, -2, 4, 10, 20, -42, 13, -92, 17, 20, -6, -8, -11, -22, -1, -21, 1, -5, -22, 4},
    {-8, -12, 3, -28, -13, -5, -3, 11, -2, 18, -6, -14, 27, 4, -4, -1, -32, -2, 32, 43, 18, -28, 5, 11, 3, 34, 30, -23, -24, -4},
    {-42, -4, 5, -11, -11, 0, -4, 1, -29, 15, 2, 18, 10, -3, -2, -21, 0, -15, 20, 49, -6, 12, 7, 42, 6, 5, -43, -16, -23, 16},
    {-34, -5, 0, 7, -24, -15, 2, 17, -7, 16, -13, 13, 29, -4, 11, -43, 23, 39, 14, -5, 3, 2, 6, 75, 22, 0, -6, -31, 14, -20},
    {6, -23, 3, 28, -32, 1, 1, 7, 4, 12, 10, -17, 7, 2, -16, 45, 1, 68, -26, -8, 20, 3, 4, 56, -2, -28, -3, -4, -4, -9},
    {12, -1, 4, 79, -14, 7, 2, 20, -4, 14, -23, 6, -3, -3, -2, 77, 9, 66, -51, 2, 30, -1, -5, 47, 6, 51, -23, -1, -17, 6},
    {-67, -6, -3, -34, 3, 1, 5, 14, 0, 7, 7, -8, 10, 9, 3, 85, 27, -11, 16, -34, 37, -36, -13, 21, -5, -8, 8, 1, -18, -22},
    {16, 15, 0, -22, 27, -5, -3, -27, 1, -16, -5, -5, -11, 0, 16, -127, 14, -35, 41, 14, -27, 5, 1, 23, -4, -8, 27, -9, 2, -6},
    {-22, -1, -18, -34, 0, -22, 3, -20, 5, -11, 0, 14, 1, -10, -5, -123, -17, -44, 36, -13, 7, 28, 11, -6, 1, -29, -27, -7, -88, -5},
    {5, -22, 14, 13, -2, -23, 1, -40, 1, 2, 10, 23, -57, -7, -13, -11, 74, -5, -16, 12, -10, 5, 4, 16, -14, -19, -31, 6, 25, 79},
    {-22, -13, -7, 24, -9, 28, -82, -25, 0, -20, -1, -18, -41, 6, 3, -76, 30, -9, -5, 11, -22, 117, 0, 7, 1, -30, -27, 8, -18, 13},
    {-40, -6, 3, 31, -59, -7, -8, 45, -8, 32, 0, 17, 20, -7, 2, 54, 4, 105, -4, 40, 27, 19, -13, 101, 4, -61, 48, 14, 32, -25},
    {21, 28, 4, -16, 31, -23, 5, -16, -1, -17, -2, 5, -30, -19, 19, 9, 0, -29, -1, 0, 20, 20, -5, -55, -2, 12, 6, 24, 19, 16},
    {-16, -1, -4, 14, 2, 1, 9, -40, -2, -18, -6, 18, -46, 5, -42, 35, 75, 24, 1, -2, 19, -4, -3, 17, 2, -9, -30, 15, -16, 30},
    {46, 21, 8, -13, 19, -3, -2, -19, -2, -19, -39, 20, -43, -2, 21, -15, 29, -92, -9, 14, 0, 28, -9, 6, -11, 52, -9, 20, 1, 22},
    {-19, 22, -8, 11, 23, -20, 6, 12, 9, -3, -10, -21, -24, 3, 17, 2, 49, 127, -6, 50, 22, 1, -14, -16, 38, 11, 12, 27, -5, 46},
    {-7, -4, -6, -6, 1, -35, -1, 2, -5, 4, 13, 28, 22, 5, -12, 17, -23, -73, 6, -17, -2, 4, 7, -15, 2, -26, -48, -17, -100, -1},
    {34, 8, -3, 24, -1, -20, -12, -32, -4, -21, -28, -15, -36, -1, 13, 7, 14, -61, -28, 3, 26, 46, 7, -7, -2, 40, -16, 32, -1, -18},
    {-40, -20, 2, 13, -25, -26, 2, -7, 2, 2, 3, 10, 11, -29, -6, 19, 6, -16, -27, -5, 36, -3, 5, 26, 0, 5, -42, -13, 66, -21},
    {23, -18, 13, 6, -6, -32, -8, 28, -4, 33, -12, 23, 20, -2, 7, 86, 2, 83, -9, 8, 8, 39, -23, 6, -11, 22, -2, 1, 18, 0},
    {-68, 7, -3, -28, 15, -32, 1, -16, 3, -6, 8, -8, 18, -2, -9, -96, -20, -70, 21, -19, -14, -46, 11, -50, 4, -13, -9, -16, 53, 0},
    {10, 4, 18, 4, 1, -16, 3, 42, -1, 22, 0, -8, -6, 6, -2, -2, -29, -3, -15, 17, -19, 9, -1, 19, -9, -17, -4, -12, 10, -1},
  },
  {
    {-43, -24, -36, -8, 13, 10, -1, 29, 3, 13, -16, -7, -20, 1, 19, 6, 22, 3, -9, -3, -27, -26, 7, 10, 3, -12, -11, 3, 4, -3},
    {43, 0, 3, 24, -15, -7, -10, -27, -3, -29, 5, -23, -18, -6, -9, -2, 8, -2, -16, 8, -22, 76, 7, -7, 0, 9, 0, 17, 18, 1},
    {-26, 9, 21, 6, 16, -10, -5, 15, -28, 19, -8, -5, -6, -5, 19, 13, -12, -4, 4, -4, 19, 2, -9, 28, -11, 20, -23, -21, 5, -16},
    {29, 2, 19, -9, -2, 22, 10, -20, -3, -24, 3, -1, 8, 4, -12, -10, 30, 0, 7, -26, -52, -18, -6, 7, 3, 20, -24, 47, 6, 1},
    {37, -9, 21, 18, -28, 11, 3, -29, -31, -31, 7, -10, -24, 8, -4, 15, 24, 5, 3, 5, -28, -1, 10, 2, -9, -7, 42, 31, -45, 5},
    {10, 10, -48, 11, -13, -19, 6, -5, -31, -17, -17, -15, 54, -2, 19, -1, -32, 0, -30, 8, -12, -33, 29, 55, 6, 24, 8, -37, -24, 13},
    {-1, -8, 6, 12, -1, -2, 2, 0, 0, -8, 5, 0, 38, 0, 1, 4, -5, -1, 1, 13, 2, -2, -50, 11, 20, 9, -2, 8, -2, 2},
    {21, -36, -13, 5, -1, -10, 19, -14, 12, 3, -4, 17, -14, -1, 7, 34, 20, 5, -2, 2, -12, -6, 17, 2, -7, -11, -2, 13, -12, -4},
    {-15, 8, -16, 15, -37, -33, 4, -17, -1, -29, -4, 21, 20, -13, 22, 26, 8, 6, -28, 3, 16, 12, 11, 37, -12, -107, -29, 30, -11, -1},
    {9, 12, 41, 2, -18, 2, -5, -4, 20, -8, 0, -3, -24, -5, 6, -16, -36, -16, 20, 8, -20, 12, -19, -45, 12, 17, 8, 8, 13, -11},
    {2, -7, -43, -41, 49, 14, 10, 45, 63, 48, -16, 10, 53, -27, -14, 57, 13, -5, 4, 13, 5, -6, -34, 2, 3, -6, 2, -23, 43, -13},
    {-30, -19, 15, 0, -22, 5, -48, -37, 2, -11, 7, -2, -18, 0, -5, 17, 22, 2, 2, 9, -22, 63, 1, -8, -5, 6, 5, 18, 48, -11},
    {23, -14, 26, 17, -14, -4, -19, -36, -44, -24, -5, 4, -32, 6, -5, -13, 10, -10, 0, 5, -26, 24, 11, 43, -9, 1, -1, 65, 3, 11},
    {-18, 8, -38, -21, -13, -24, -1, 10, -7, 23, -19, 6, 47, -31, -11, 38, -19, 11, -20, 23, -31, 2, 6, 37, -16, -13, 2, -12, 73, -8},
    {-19, 1, -10, -7, -6, -10, 4, -2, 0, -15, -4, -2, -35, -36, -6, 64, 1, 3, -11, 0, -10, -7, 5, -16, 8, -13, -4, 12, 76, 8},
    {-41, -38, 24, 16, -24, -13, -2, -19, 11, -28, -2, -35, 69, -2, 27, 9, 20, -2, -10, -9, -21, -32, 23, -18, -1, -33, 14, -20, -58, -9},
    {-21, 11, 28, -14, 5, 11, 4, -9, 7, -6, 11, 13, -31, -1, -4, 12, 24, 1, 21, -6, -31, -9, -11, -7, -10, 29, -1, 37, 21, -9},
    {-14, -21, -18, -10, 13, 3, 2, -5, -1, 21, -43, 4, 37, -9, 2, 32, 43, 20, -9, -28, -8, -5, 6, 16, -25, 79, -11, -29, 17, -30},
    {-19, -13, 35, 15, -17, -12, 7, -19, 22, -31, 18, -27, -39, -17, -15, 10, 49, -3, 3, -4, 27, -4, -1, -34, 9, -31, 13, 55, 5, 7},
    {26, -11, 19, -7, 0, -33, -8, -17, 30, 10, 6, 5, -12, -1, -12, 31, 0, 1, 23, -14, 52, 42, -4, -36, -4, -14, 3, -4, -8, 2},
    {13, 11, 3, 8, -27, 10, -6, -30, 5, -24, 7, -5, -29, -6, -5, -14, 0, 3, -8, 25, -41, 65, -4, -6, -1, -5, -45, 34, 18, -10},
    {-30, 2, -57, -70, 43, 33, -3, 19, 75, 64, -41, -21, 116, -32, -25, -127, -10, 12, 12, -2, 7, 12, 28, 30, -6, 15, 4, -29, 60, -16},
    {-12, 13, -48, -40, 19, -30, -2, 10, 16, 36, -26, 2, -6, -7, -15, 39, -11, 6, 3, -11, 52, 8, 15, 34, -11, 3, -9, 2, 20, -8},
    {7, -13, 3, -1, -34, -11, -10, -12, 16, -18, 20, -4, -66, -9, -1, 22, 43, 18, 18, 14, 5, -3, -18, -12, -6, -27, -11, 60, 14, -13},
    {83, 18, 52, 19, -27, 1, -11, -55, 3, -39, 17, -17, -27, 9, -28, -1, 11, -7, 16, 13, 7, 77, 9, -20, 10, 22, 22, 39, -10, 0},
    {-35, 47, -33, -15, 31, -5, -4, 27, 2, 24, -8, 52, 41, 19, 14, 32, -35, 7, 7, -20, 18, -26, -4, 37, -1, -12, -17, -23, 2, -2},
    {-54, 5, -11, 42, -38, -3, 5, 1, -48, -26, 10, 33, -12, -18, 20, -11, -14, -1, -41, 7, -11, 11, 3, 17, 10, -25, -21, 12, -59, -17},
    {10, 14, -7, 0, 19, -17, 0, 23, 15, 30, -7, -3, 41, -10, 4, 13, -19, 0, -7, 6, 33, 5, -7, -12, -5, 14, 20, -63, 25, -10},
    {-14, 1, -48, -37, 8, -37, -3, 7, 9, 34, -25, 7, 91, -20, -23, 42, -13, 4, -9, 22, 31, 15, 10, 36, -14, -31, -12, -24, 49, -5},
    {5, 21, -7, 30, -17, 29, 7, -13, 13, -49, 9, 6, 36, 1, 6, 71, 36, 11, -34, 16, -29, -21, 4, -3, 2, -12, -22, 17, -36, 10},
    {-22, -6, -22, -59, -3, -8, 13, -9, -18, 30, -28, 5, 1, -14, 4, 23, 53, -4, 1, -2, -6, -22, -14, 5, -35, -34, 7, -31, 39, -20},
    {-3, -16, 26, -24, 10, 7, -5, 19, 6, -24, -44, 1, 29, 1, -7, 2, 24, -35, -7, -3, -5, 7, -9, -5, 16, 44, -8, -18, -1, 1},
  },
  {
    {-38, -48, -48, 32, 19, 8, -14, 26, 6, 44, -21, 8, -22, 24, -25, 41, 33, 4, -31, -17, 6, -22, 3, 40, -9, -4, -9, -9, -3, 12},
    {39, 15, -56, 12, 1, 6, 16, -17, -9, 13, -8, 14, -13, 7, -5, -35, -49, 9, -11, 26, -49, -66, 3, 44, 16, 1, 0, -44, -21, -2},
    {-31, -15, 16, -42, -43, -7, -17, -43, -5, -25, 12, -19, 9, 1, -16, 7, 3, 0, 46, -2, -12, 55, 5, 0, -2, 3, -10, -10, 24, 5},
    {43, -6, 15, -20, -11, 7, -33, -35, -9, -22, 0, -3, 4, 5, -12, -47, 20, 1, 32, -9, -12, -25, 10, 6, -21, 9, -25, 11, 4, 8},
    {-7, -7, -8, 12, 11, 7, -2, -9, -7, 10, 3, 8, -50, -4, 8, 14, 5, 16, -18, -48, 1, 10, 17, 2, -28, -3, -12, 70, 7, -45},
    {-5, -2, -32, 18, 2, -38, 8, 1, 11, 15, -15, 9, -13, -16, -30, -18, -12, 7, -18, -6, 69, -10, 8, 14, -10, -5, -5, -17, 1, -16},
    {-2, 1, -14, 13, -4, -35, 3, 1, -3, 8, -10, 5, -16, 11, -14, 14, -7, 5, -14, 2, 56, 4, 8, 22, -4, -3, -14, -12, -20, -27},
    {2, 8, -42, 25, 7, -33, 6, 1, -7, 20, -20, 8, -19, -7, -44, 8, -22, 11, -26, -31, 64, 24, 13, 28, -19, -4, -11, -10, 3, 1},
    {-9, 4, -27, 10, -2, -12, 14, -15, -12, 12, -4, -1, -5, 21, 44, 9, -22, 10, -19, -2, -14, 23, 38, 28, -22, 7, -6, 18, -1, -50},
    {-18, 3, 27, -29, -21, -5, -29, -25, 6, -31, 14, -1, 12, 32, 18, 5, -21, 3, 25, -41, -1, -1, 8, -48, -1, 4, -7, -2, -25, -3},
    {-4, -11, 5, -3, -3, 2, 0, -1, 4, 2, 3, 4, 0, 5, 10, 1, 17, -6, 6, 40, 6, 5, 8, 21, 20, 0, -2, -6, -10, -20},
    {19, 14, -8, -31, -52, 1, -10, -80, 6, -37, 13, -8, 23, 7, 12, -11, 2, 7, 40, 36, -20, -2, 33, 52, -9, -5, -4, -28, -14, 5},
    {-7, -6, -2, -1, 1, -5, -9, -11, -8, 8, -9, -8, -10, 1, -4, 10, 2, -9, -6, 1, -6, 7, 10, -6, -3, -8, -1, -8, -8, -2},
    {-4, -96, -29, 22, 11, 8, -6, 16, 2, 40, -24, 3, -35, 6, -32, 9, 74, 3, -20, -23, -15, -13, -1, 15, -47, -10, -9, -10, 0, -9},
    {16, 5, 11, 15, 14, 1, 11, 1, -28, 18, -6, 9, -8, 5, 2, 5, -5, -6, -21, 4, -12, -15, -1, 32, -8, 13, 3, 3, 7, -1},
    {-22, 24, -8, -20, -19, 9, -18, -62, -44, -29, 12, 14, 0, 17, -12, 6, -30, 6, 20, -1, -37, -36, 25, 11, 4, 1, -7, -15, -26, 19},
    {-25, 12, -24, 14, -4, 2, 8, 8, -13, 2, -6, 26, -10, -9, -1, -33, -38, 1, -11, 44, -25, -56, 0, 31, 33, 4, 8, 11, -10, -1},
    {19, 11, 3, -19, -38, 3, -18, -71, -8, -9, 3, -10, -1, 12, 12, -15, -13, -4, 25, 26, 7, 38, 10, 22, -24, -3, -4, -3, -24, -27},
    {-93, -19, 36, -17, 14, -15, 3, -13, 10, -26, 15, -8, -5, 41, 15, 68, 6, 9, 5, -1, 42, 29, -21, -20, 36, 24, 15, 34, -64, 14},
    {7, -18, 28, -7, -56, 5, -2, -13, 22, -6, -3, -14, 6, 4, 16, -16, 8, -11, 4, 3, -3, -2, 20, -25, 19, 9, 20, 5, -14, -23},
    {29, -7, 10, -30, -59, 4, -29, -39, -15, -19, 10, -11, 7, 9, 1, -15, -5, -5, 36, -2, 4, 58, 0, 19, -6, -1, -4, -12, -15, -20},
    {-14, -13, -12, 15, 33, -2, 8, 42, 78, 37, -13, -11, -27, -12, -12, 9, -2, -11, -12, 66, 19, 12, -19, -35, 43, 24, 22, 43, 19, -8},
    {46, 6, -33, 18, 18, -9, -9, -12, 0, 21, -5, -9, -12, 17, 17, 46, -25, -3, -16, 62, 8, 27, 14, 69, -12, -6, 10, -13, -31, -16},
    {-5, 2, 22, -5, 18, -2, -4, 19, -23, 9, 7, 1, 7, 12, -13, 4, 13, 1, -7, -14, 9, 7, -15, 6, -24, 6, -7, 28, -13, -23},
    {19, 9, 38, -10, -15, -1, -2, -8, 8, -17, 10, -2, 9, 0, 10, 2, 24, 1, 5, -13, 0, 26, -12, -28, 39, 13, 23, 33, 12, -7},
    {-29, -14, 43, -20, -9, 5, 19, 22, -47, -8, 12, -21, 22, -28, 8, 6, 27, 3, 9, -17, -8, -53, -37, 4, -15, -1, 27, -50, 25, -12},
    {-23, 16, 35, -38, -13, 1, -15, -69, 31, -39, 17, 7, 6, -8, -12, 32, 23, -9, 49, -43, -16, 78, 19, -20, -29, -6, -30, 35, -6, 13},
    {18, -1, 17, -40, -13, -4, -12, -43, -13, -30, 10, -11, 10, 31, 8, -2, 17, -2, 45, -17, -4, 14, 11, 2, -19, -4, 18, 5, -52, -8},
    {-11, -13, -15, 17, 21, 4, -9, -3, 9, 17, -6, 12, -8, 8, -2, -34, 2, 0, -18, 30, -7, 8, -4, 14, 22, 5, 13, 12, -8, -4},
    {23, -5, -9, 12, 12, -8, 1, -3, 12, 17, -3, -2, -6, -4, -4, 8, 7, 1, -18, -18, -8, 22, -6, -1, 5, 2, 12, 1, 3, 6},
    {-15, -11, 3, 21, -57, 23, 9, 61, 20, 5, -5, 6, 10, -7, 11, -8, 20, 1, -16, 110, 3, -20, -22, 4, 29, 4, -18, 14, -28, -31},
    {33, 7, 1, -28, -36, -2, -15, -13, 21, -28, -5, -9, 3, 5, -15, -26, 18, 6, 28, 0, 10, 26, 6, 15, -1, -5, 5, -18, -23, 13},
  },
  {
    {-10, -24, -12, -31, 14, 26, 0, 20, 14, 18, -4, -14, -16, 2, -9, 29, 14, -1, 16, -13, -2, -8, 7, -1, 0, -19, 1, -13, -29, 5},
    {2, 3, 7, -8, -110, 3, -1, -43, -12, -60, -7, 13, 2, 0, 6, -6, 17, 2, -27, 53, -11, 14, -1, -5, 16, 15, -3, 7, 18, -41},
    {-36, 30, 30, 12, -17, -48, 24, -15, -7, -25, -12, 23, 30, 2, 19, 37, -1, -11, 14, -32, 6, 18, 0, -3, 7, 15, -4, 4, -2, 57},
    {10, 10, 2, 20, -10, 3, 3, -11, -14, -10, -9, 2, 3, -30, 16, -74, 4, -2, -32, -9, -10, 10, 2, -2, 5, -15, 1, -19, 58, -11},
    {-14, 5, -7, -7, -5, 3, 5, 3, 11, 23, 4, 2, -17, 8, -6, 21, -20, 13, 2, 36, -10, -15, 18, -3, -13, -23, 7, 17, -1, 22},
    {-2, 3, -31, -52, 3, -51, 33, 7, 9, 21, 17, -40, -26, 4, -24, 37, -9, 3, 2, 11, 7, -102, 7, 2, -4, -7, 2, -11, -12, -22},
    {-4, 4, -15, -35, 5, 7, 3, -4, 0, -6, 4, -15, -9, 13, -100, -4, 10, 6, -9, -47, -5, -10, 5, 3, 4, -1, 4, -6, -8, 45},
    {-9, -7, -11, 17, 11, 21, 0, -3, -2, -18, 6, -4, -8, 29, -4, 36, -7, -1, -52, 54, -25, 2, 9, -2, 16, 15, -6, -5, 11, -3},
    {13, -19, 6, 18, 9, -38, -60, -37, -26, -26, 15, 35, -1, 3, 5, -20, -3, 1, -78, -83, 7, 52, 29, 3, 24, -29, -5, -20, 30, 101},
    {-16, -3, 15, -24, -8, 63, -83, -19, -16, -32, -89, 24, 3, -8, -1, -30, 18, -5, -2, -54, -58, 27, 7, -6, 15, -12, -6, 5, -2, -10},
    {15, -12, -1, 21, -1, 13, 22, 13, 12, 23, -5, 1, 5, -12, 7, 6, 17, -3, -48, 41, -38, -42, -11, -7, -18, 11, 0, 8, 4, -43},
    {-6, 8, 24, 7, -24, 11, -41, -28, -27, -61, 7, 25, 15, -3, 4, 14, 30, 0, -11, -32, -45, 28, 11, -1, 19, -11, 4, -7, -3, -14},
    {9, -5, -35, 22, 5, -32, -66, 5, 8, 11, 25, -24, -21, -23, -11, -24, -3, 7, -52, 8, -26, 13, -3, -3, 0, -37, 2, 4, -3, -33},
    {30, -30, -48, -36, 24, 2, 19, 13, 1, -14, -19, -41, -26, -31, -28, -13, 34, 14, -4, -60, 10, 7, -3, 3, 17, 5, -1, 1, -15, -56},
    {20, -19, 11, 11, 6, 3, -7, -16, -2, -31, 13, 4, 7, 9, 4, -9, 28, 1, -31, -11, 0, -2, 14, 1, 6, -28, 1, 25, 3, 34},
    {31, -22, -7, -23, 11, 18, 14, -7, -9, -6, 23, 4, -13, 64, -8, 51, 24, 9, 20, -11, -64, -11, 20, 9, 6, -21, -15, -9, -21, -10},
    {1, 10, 4, -17, 5, 4, -7, 15, -7, -2, -3, -7, 0, -8, -26, -4, -8, 2, -33, 8, 3, 19, 3, 12, 12, 15, 21, 31, 11, 43},
    {4, 7, 5, 0, -1, 4, 29, -4, -5, -9, -15, 5, 12, 7, 6, 5, 8, 0, 17, -14, 11, -33, 5, 2, 2, 17, 4, -5, 2, -3},
    {5, 9, 4, -3, -61, 11, -15, -20, -24, -41, -39, 11, 14, 8, 13, -13, 17, 6, -16, -7, -10, 19, -1, -1, 3, 55, 5, -2, 28, -27},
    {44, 22, 22, -7, -9, 0, -23, -14, -8, -25, -8, 20, 14, 28, 6, 18, -5, -1, 39, -16, -26, 37, 5, 0, 12, 16, -2, -5, -26, -10},
    {-53, -8, 17, 5, -12, -85, -8, -16, -16, -32, -5, 14, 19, 18, 6, 30, 18, -1, 9, 45, 49, -24, 0, 0, 7, -5, 0, 2, -24, 20},
    {-8, -6, -12, -8, 3, -25, 35, 15, 17, 27, 2, -13, -12, -21, -6, 16, -1, -4, -17, 42, 24, -18, -4, -1, -8, 6, -3, -2, 22, 13},
    {-26, -20, -23, 17, -11, -17, -9, -7, 21, 35, 12, -8, -3, 19, -5, 19, 31, 15, -23, -12, 28, 20, 25, 7, -5, -4, -9, -25, 0, -27},
    {29, -2, 32, 6, -20, 8, -9, -12, -7, -55, -123, 19, 0, 1, -13, -32, 32, -4, 20, -16, -10, 1, -8, -10, 18, 18, 4, 21, 32, 26},
    {9, 2, 6, -12, 6, 1, 0, 6, 4, -1, -5, 1, 3, -1, -16, 14, 2, -3, 15, -3, 0, 7, -2, 3, -1, 3, -3, 17, 16, 29},
    {-6, 11, 6, -11, -3, 6, 8, 5, -3, -8, 11, 1, 20, 12, 11, 25, -3, 8, 4, 3, 1, -26, -6, -1, -19, -4, -2, -6, -28, -25},
    {-5, -4, 13, 13, -47, -28, 7, -30, -24, -50, 6, 14, 12, -1, 3, -25, 24, 4, -14, -1, -3, 28, 3, -5, 9, 43, 4, 0, 43, -10},
    {1, 13, -20, -6, 6, 1, 11, -31, -18, -6, -19, -3, -1, 5, -8, -34, -4, 13, -41, -4, 6, 19, 27, 2, 8, 43, -2, -6, -2, 56},
    {8, -30, -10, 7, -10, 11, 12, 0, 0, 5, 6, 0, -2, -49, 7, -9, 22, 4, -35, 53, -12, 1, 0, -2, 0, -10, -7, 8, 31, -19},
    {0, -1, 11, 14, -34, 13, -6, -5, -1, 4, -11, 11, 4, 8, -3, -7, 4, 7, -11, 43, -27, 12, 16, -9, -8, 6, 10, 26, 9, 27},
    {-12, -12, -33, -30, 26, 23, -6, 10, 15, 10, -2, -29, -32, 2, -43, 25, 47, 3, -22, 53, -7, -6, -8, 7, -3, 1, 8, -2, 15, 8},
    {3, 5, -15, -1, 11, -1, 16, 4, -10, -4, 17, -11, -9, -5, 3, 26, -11, 3, -27, 17, -6, -9, 2, 8, 4, 19, -3, -22, -107, -37},
  },
  {
    {-2, -42, -72, -42, 9, 26, -29, 23, 6, 17, -15, 12, -28, -20, -30, 15, 1, 35, 7, -44, -5, 1, -11, 19, 1, 7, -17, 2, 13, 51},
    {-41, 5, 18, 16, -35, -24, 0, -24, -2, -24, -7, 0, 10, -8, 12, 12, -3, 2, -33, 6, -9, 4, -10, -15, 0, 25, 13, -10, 21, 21},
    {-31, 21, 10, 24, -13, -39, 19, -33, -24, -70, 24, 4, 14, 9, -6, -19, 3, 6, -41, -97, -9, 10, -35, -6, 13, 53, 14, -20, -20, -11},
    {14, 2, -3, 10, -14, -15, -3, -20, -2, -13, -6, -4, -4, 3, -23, 11, -16, -1, -9, -11, 2, 0, 10, 10, 10, 7, 12, -7, 34, 36},
    {14, 2, -34, 3, -21, -18, -25, 11, 37, 5, 6, -21, 0, 25, 11, 6, -47, 3, -28, 20, 5, -11, 15, -59, -6, -29, -22, 25, 24, 0},
    {12, 5, 5, -43, 11, 1, -2, -4, -2, 6, 0, 0, 2, 5, 4, -26, -4, 5, 59, -15, 0, 4, 6, 9, -8, 4, -14, 2, -14, 21},
    {-18, 3, -20, 1, -29, -20, -3, -34, -20, -22, -42, 9, 8, 6, 6, -18, -7, 23, -38, -58, -11, 5, 20, 8, 3, -10, 37, 0, 8, 26},
    {-9, -7, -2, 14, 0, -8, -13, -13, 22, -17, 6, -30, -6, 34, -12, 20, -11, -23, -26, 58, -2, 3, 21, -1, 19, 5, 13, -15, 0, 21},
    {-35, 23, 1, -16, -30, -19, 13, 12, -67, -31, -11, -30, 0, 1, -33, 44, 14, 32, 8, 46, -5, -3, -9, 44, 2, -5, 15, 11, 13, 27},
    {-1, 12, 4, 10, -6, -14, 13, -7, 9, -9, -12, 16, 15, -7, 4, -8, 12, 10, 5, 35, -1, 2, -7, -16, -5, 10, 28, -2, 6, 12},
    {24, -19, -10, -8, -3, 11, -27, 6, 11, 6, 17, -28, -35, -14, -32, -21, -7, -10, -20, 41, -2, 0, 18, 17, 15, -23, -40, 9, -6, 23},
    {-44, 20, 23, 16, -11, -33, 12, -25, -15, -26, -9, 11, 21, -8, -14, 10, -25, -3, -29, 108, -5, 4, -5, -15, -6, 47, 6, 2, -73, 25},
    {-26, 8, -60, 25, -7, -29, -5, -34, -74, -11, 9, -36, 6, 4, 3, -18, -37, 12, -90, -2, -3, 4, 17, 49, 9, -10, 13, -3, -14, 20},
    {5, -34, -50, -65, 9, 3, -18, 2, -12, 1, 0, 17, -6, -7, -20, 4, 4, 23, 13, -82, -3, 2, 2, 15, 4, -2, -24, -5, 7, 55},
    {16, 5, 15, 4, -8, -5, 5, -8, 18, -11, -2, 3, 7, -6, -21, 7, 15, 17, 0, 1, -4, 1, 22, -1, 15, -22, -25, 11, 28, 24},
    {-37, 7, -3, -7, -13, -18, -5, -14, 19, -5, -11, -10, 5, 25, 0, 13, -25, 2, -8, -36, 3, -6, 25, 1, 3, 14, 16, 18, 15, 16},
    {-7, 5, 11, -8, 5, 10, 1, 6, 16, 8, 2, 8, -11, 3, 1, 12, 9, -13, 4, 6, 3, -7, 12, 9, 4, -5, -30, 11, -14, -2},
    {21, 15, 14, -19, 10, 0, 24, -19, -17, -14, -10, 10, -6, 15, -5, -34, 8, 17, 17, 11, -2, 0, 23, 22, 15, 11, -29, 3, -2, -9},
    {3, 15, 29, -3, -11, -18, 25, -1, -30, -19, -37, -1, 16, 8, 3, -15, 42, 13, 23, -46, -2, 3, -17, -14, -4, 59, 23, 3, 29, -3},
    {48, 0, -28, -1, -10, -4, 1, -1, 23, 2, -11, -16, 7, 63, 32, 12, 9, 21, 9, -8, -7, 5, 22, 26, 3, 21, 35, 10, -20, -24},
    {-11, 10, 2, 21, -23, -30, 5, -19, -7, -33, -19, 12, 15, -3, 6, -4, -1, 20, -27, -37, -3, 5, -10, -15, -3, 41, -1, -7, 40, 16},
    {12, -12, 0, -9, 56, 2, -15, 0, 2, -19, -8, 16, -4, -9, -23, -11, 8, 2, -22, 7, -5, -3, 12, 0, 22, 9, -10, 3, -13, 12},
    {-16, -19, -35, -9, -4, 21, -27, 10, -17, 16, 6, 38, -24, 13, -18, 36, -16, 5, -7, 1, -3, -2, 9, 33, 1, -7, -39, 5, -2, 32},
    {20, 3, -11, -1, 2, -22, 3, -16, -13, -23, -6, -18, 19, 39, -12, -50, -29, 31, 27, -29, -4, -1, -4, -2, -5, -6, -9, -30, -1, 37},
    {24, 4, -11, 14, 8, 2, 11, 6, -22, -4, 6, 23, 3, 6, 1, 9, 23, 10, -3, -32, -5, 3, -8, 33, -2, -2, -12, 2, 10, -2},
    {-10, 27, 15, 19, 1, -15, 18, -12, -37, -14, 18, -13, 9, 7, 18, -10, 4, -1, 0, 14, -1, -1, 3, 12, 1, -30, 6, 5, -15, -10},
    {1, 10, 122, 16, -27, -3, 11, -26, -42, -11, 1, -107, 21, 22, 3, -40, 11, -43, 54, 9, -5, 7, 7, 37, 5, -1, 64, -15, 12, 41},
    {-25, 23, -4, 7, -12, -28, 15, -27, 4, -33, -4, -42, 36, 5, -1, 9, -5, 26, 1, -37, -3, -2, 15, -19, 4, 15, 67, -3, 11, 21},
    {12, -9, -16, -6, 6, 11, -10, 2, 23, 11, 12, -11, -16, -18, -13, -9, -7, -1, 3, 46, 0, -2, 8, 2, 5, -11, -31, 0, 4, 0},
    {-5, 3, -7, -5, 1, 1, 15, -5, -7, 12, 1, -7, 6, 24, 15, -12, 10, 13, 17, -10, 1, 0, -3, -2, -14, 18, 8, 4, 9, -20},
    {7, -4, -17, 2, -10, 11, -6, 9, 18, 13, -4, -6, 2, -2, -3, 2, -2, 26, 1, 32, 5, -1, 1, -4, 0, 3, -4, -6, 3, 12},
    {-8, 3, -3, -20, 8, 2, 0, 17, 13, -21, 2, 10, 13, -16, -11, 22, -4, -7, 13, 17, -9, -4, -55, -18, 35, 5, -42, -6, 14, 19},
  },
  {
    {7, -48, -27, -40, 15, 8, -48, 10, 8, -3, -4, -29, 20, -10, 13, 20, 2, 8, -22, -46, -5, 4, 2, -45, 14, -17, 36, -13, -5, -7},
    {-23, -43, 15, -21, 8, 4, 6, -2, 10, 11, 2, 8, -22, -59, -21, 18, 31, -68, 31, -11, -13, 5, -11, 6, -20, 16, 5, 22, 26, 1},
    {-4, 20, 43, 21, -21, -23, 19, -29, 13, -24, -11, 39, -20, 21, -3, -4, 11, -2, 1, -40, -4, 9, 2, -10, -6, 19, -40, 51, -1, -12},
    {21, 10, -57, 14, -10, -27, -8, -13, 15, -29, 2, -16, -17, 3, 20, 35, -15, 43, -8, -20, 1, 0, 3, -13, 4, -6, 8, 17, 7, -11},
    {21, 15, 10, 8, -14, -16, -4, 8, -16, -8, 9, 25, -6, 30, 12, -28, -12, -13, -24, 16, 4, -9, 21, 7, 9, -35, -9, 2, 8, -11},
    {-17, 14, 7, 24, -39, -41, 0, -32, -1, -20, -18, 16, 16, 1, -41, -3, -11, 12, -18, 8, 2, 5, 3, -19, -6, 18, -21, 29, 3, 7},
    {-2, 18, 1, 5, -23, -14, 3, -6, 3, -7, -2, 23, -22, 9, 0, -11, -73, -2, -9, 11, 1, -6, 16, -7, 5, -1, 0, 48, 4, -10},
    {15, 21, 45, 3, -22, -12, 17, -4, -7, 8, -10, 29, -9, 7, 20, 10, 9, -13, 18, 47, 4, 1, 1, 9, -15, 19, -21, 13, -1, -24},
    {-14, 24, 3, 27, -27, -31, 6, -27, -6, -18, -33, 27, 17, 11, -30, -3, -8, 14, -26, 7, -1, 5, 3, -6, -6, 48, -30, 21, -2, 10},
    {-8, 19, 9, 11, -15, -10, 14, -8, -8, -9, -26, 21, 36, 2, -18, -9, 6, 3, -3, -2, -1, 3, -1, 26, -1, 13, -18, 28, -2, 14},
    {-18, -11, -56, 7, 29, 35, -14, 20, -20, 24, 6, -31, -49, 9, -19, 34, -31, 21, -6, -15, 1, -2, 1, -1, -8, 2, 20, 26, -29, 21},
    {-78, -6, -5, 11, -31, -2, -25, 12, 7, 5, 11, -14, -34, -42, -22, 64, -13, -32, -30, 59, -5, -1, -11, 0, -8, -12, 20, 23, 29, -2},
    {-9, -6, -3, -2, 0, -8, -9, -13, -9, 3, -9, -8, -10, 0, -4, 8, 1, -8, -6, 1, -7, 7, 9, -6, -3, -8, -2, -8, -9, -4},
    {8, 5, -4, 18, 2, -7, 11, -7, 1, -6, -5, -3, -1, 12, 11, -25, 13, 7, -20, 25, -1, 0, -67, -7, -23, 24, 10, 19, 6, -18},
    {3, -2, 3, 14, -52, 7, 9, 4, 17, 27, 5, 5, -14, 3, -22, -4, 2, 7, 0, 52, 5, 3, -24, -24, -16, -5, -9, 14, 7, 19},
    {-8, -12, -33, 11, 4, -11, -15, -7, 22, -19, -5, -18, -19, 48, 9, 41, -9, 11, -31, -26, -4, -1, -2, -28, 8, -10, 9, 9, -52, 7},
    {-84, -17, 8, -35, 3, -6, -11, -5, -2, 8, -10, -4, -25, 13, 12, 22, -2, -73, 13, -1, 5, 4, 9, -10, -3, 22, 5, 1, -85, -17},
    {24, 25, 16, 1, 8, -15, 17, -15, 13, -16, -3, 26, -9, 29, 6, -48, -6, 14, 17, -49, 1, 1, 1, -35, 4, -2, -25, 25, -19, -12},
    {7, 14, -8, -15, -48, 1, 12, -1, -30, -20, -14, 35, -17, 36, -2, 3, 35, 28, -1, 40, -9, 9, -24, 39, 2, -2, -33, -14, 18, 2},
    {19, 10, -10, -7, 5, 13, -6, 6, 13, 23, -9, 20, 0, 71, -22, 22, -8, 18, 3, -13, 2, 1, 28, -16, -7, 5, -9, 8, -27, 41},
    {-19, 27, 5, -1, -19, -22, 30, -24, -3, -28, -35, 40, 0, 8, -23, 1, 28, 13, 16, -17, 1, 1, 4, 4, 4, 53, -32, 44, 13, 12},
    {3, -32, -34, -22, 24, 20, -38, 23, -19, 13, -10, -37, -8, -39, 22, 54, -3, 1, -15, 23, -7, 3, -3, 3, 2, -10, 36, 3, 3, -12},
    {-5, -17, -16, 17, 30, 31, -30, 23, 30, 45, 28, -12, 71, -30, -13, 34, -30, 1, -34, 50, 5, -3, 5, -55, -32, -28, 7, -43, 2, -45},
    {4, 5, 0, 3, -71, -19, 5, -7, 6, -22, 6, 7, -24, -17, 6, -2, -5, 12, -5, 40, 9, -1, 0, -4, 9, -7, -11, 37, 30, -8},
    {18, -27, 34, -7, 12, 14, 0, 11, 14, 17, -4, 7, 28, -5, 5, 4, 21, -22, -5, -1, 0, -2, -12, -20, -13, 3, -2, -27, 1, 10},
    {-18, 14, 7, 6, 2, -5, 18, -4, -12, -8, 7, 24, -1, -10, -13, 19, 4, -12, 0, 9, -1, -2, 0, 13, 0, -11, -11, -10, -14, 11},
    {-10, 0, -1, 15, -27, -34, -2, -20, 2, -20, 13, 18, -23, 18, -10, -18, -29, 15, -13, -13, -6, 8, 1, -11, -6, 0, -33, 55, 1, -10},
    {3, 51, 24, 6, -4, -15, 14, -2, 15, -2, -3, 16, -25, 19, -5, -16, -10, -6, 11, 3, 2, -5, 3, -25, -3, -7, -9, 40, -9, -5},
    {6, -25, -9, -12, 12, 21, -18, 17, -1, 28, 0, -31, -21, -31, 9, 0, -7, -4, -1, -1, 5, -2, -2, -16, -5, -6, 27, -47, 13, 7},
    {-11, -25, -8, 2, 12, 4, -23, -3, 5, -6, 4, -24, -3, -17, 9, 49, 5, -7, -14, 52, -4, 7, 0, -32, 9, -15, 18, 9, 13, 3},
    {-7, -48, -33, -50, 10, 4, -32, 13, -3, 3, 29, -32, -21, 2, 12, 20, 11, 1, 21, -30, -3, -3, 6, -18, 8, -36, 41, 7, -3, -14},
    {-6, 5, 5, 1, 4, 12, 4, 7, -6, 17, 3, -4, 3, -2, 7, 23, 26, -10, -4, -2, 0, -10, 14, -2, -8, -9, 30, -16, -2, 5},
  },
  {
    {7, -26, -48, -11, -24, -44, -21, 26, 29, 35, 25, 7, 12, 7, 12, 16, -5, 10, -2, 6, 39, -4, 12, 3, -10, -13, -37, -12, -2, 7},
    {-11, 9, 18, -27, 12, -23, 13, -10, -16, 3, -28, -3, -55, 36, -11, 12, 0, 1, 44, 7, -16, 8, 1, 4, -3, 15, 6, -5, 5, 13},
    {-10, 19, 24, 18, 12, -11, 21, -12, -15, -8, 18, -8, -8, -20, -15, -4, -7, -5, 3, 7, 12, -3, 9, 5, -1, 26, 6, 5, -8, 6},
    {14, 23, 17, 6, -9, -9, -12, -22, -23, 0, 4, 10, 17, 15, 13, -14, -19, -23, -48, 2, -13, -15, 16, 0, 6, -5, -25, -56, 5, 26},
    {15, -8, 102, -9, 7, -12, 4, -32, 1, 0, 4, -17, 9, 16, 11, -16, 6, -39, 35, 5, 3, 6, -11, 3, 7, 33, 17, -25, 9, -9},
    {19, -13, -33, 11, 5, 17, -2, 24, 14, 22, -1, 20, 5, -41, 1, -23, 2, 23, -19, -12, -24, 1, -34, 0, -31, -3, -53, 7, 28, -16},
    {28, 20, -9, -9, 5, 10, -11, -3, 15, -5, -12, -1, 15, 5, 15, 1, -12, 31, -11, -3, -12, -2, -10, -5, 20, 10, -8, -34, -9, 2},
    {5, 26, -23, 7, 3, 11, -4, 4, -15, -9, -1, 15, -11, 46, -4, 22, -18, 2, -19, -4, -27, -11, 5, -3, 12, 21, -26, -3, -20, 21},
    {-5, -3, 44, -5, 7, -14, 8, -13, -10, -7, -2, -14, 2, -21, -1, -6, 3, -74, -6, -4, 17, 2, 25, 9, 3, 40, 4, 17, -13, -15},
    {-10, 22, 39, 2, 18, 3, 16, 9, -14, -9, -28, 1, 15, -11, -3, -7, -3, -17, 22, -1, -38, 4, -20, -3, -1, 17, 17, 3, 14, 5},
    {-23, -2, -43, -22, -13, 2, -16, -1, 9, 6, 13, 4, 19, 26, 6, 22, -4, -8, -14, 0, -11, -7, 19, 3, 1, 22, -46, -23, 0, -2},
    {1, -6, 15, -1, -8, -46, -6, -27, -16, 1, -108, -7, 35, 16, 2, -6, 3, -18, -1, 4, 7, -4, 10, 3, -1, 18, -8, -24, -5, 4},
    {-7, 17, 13, 7, 17, -34, 22, -12, -12, -18, 5, -24, -6, 12, -7, 6, -14, -7, 19, 4, 19, -2, 22, 10, 17, -24, -5, 18, -3, 15},
    {-16, -5, -13, 5, 7, -3, 1, 50, 9, 11, -12, 19, 2, 1, -2, 8, 5, 3, -15, -3, 2, 4, -26, -2, -10, 7, -19, -2, 10, 1},
    {5, 8, 44, -57, 32, -6, 7, -30, 8, -14, -3, -24, -11, 64, -10, 11, 9, 30, 56, -17, 30, 13, -15, 0, -12, -10, 25, -2, -12, -3},
    {-9, 26, -8, -2, 13, 11, 7, -1, 0, 1, -2, 8, 0, 26, -7, 44, -16, -1, 5, -7, -13, -9, 11, -2, 1, 9, -18, 3, -10, 20},
    {-24, 20, 53, 13, 28, -16, 31, -52, -30, -44, -9, -5, 32, 64, -18, -12, 1, -2, 27, 1, -14, 4, 8, -2, 4, 65, 19, 47, -8, -10},
    {13, -3, 22, -9, -4, 2, -1, -48, -15, -30, -21, 5, 2, 5, 7, -51, 7, 0, 9, 10, 0, 2, 26, 2, 16, 24, -11, -12, 38, -8},
    {-10, 1, 12, 8, 14, -4, 8, 34, 14, 17, 11, 6, 3, -2, 6, 27, 3, -26, 2, -9, -1, -5, 1, 6, -5, -22, -12, 4, 10, 7},
    {-8, 12, -7, 5, 3, 32, 7, 7, -6, 2, -46, 8, -50, 22, -5, 10, -2, 0, 10, 4, -32, 4, -16, 1, -7, 42, 6, 31, -13, 0},
    {-18, 15, 18, 6, 24, 32, 18, -14, -20, -21, -39, 5, -53, 8, -16, 4, 8, 3, 17, -7, -23, 5, -6, -3, 1, 26, 2, 54, -3, 2},
    {3, -12, -22, -43, -16, 12, -39, 13, 2, 3, -14, -3, -15, -70, 7, 0, -2, -9, 3, -7, 0, 5, -1, 9, 9, 6, -18, 7, 48, 5},
    {11, -16, 11, -21, -23, 12, -19, -3, 18, 24, -11, 2, -19, -3, 7, -3, -6, -5, 15, 11, 22, 2, 21, 1, -2, 43, -1, 6, -25, 5},
    {2, 16, 4, 11, -4, 0, 6, -38, -22, -24, -37, 16, 2, -2, 0, -4, -3, 18, 8, 13, -1, -1, -30, 0, -25, 62, -18, -10, 22, -4},
    {6, -5, -71, 4, -9, -4, -2, 20, 2, -8, 17, 13, 1, 16, 16, 5, -6, 39, -20, 1, 12, -4, -1, 2, -5, 14, -26, -14, 2, -8},
    {-36, 6, 14, 15, 25, 33, 21, -33, -41, -36, 9, -2, -21, 33, -18, 6, 9, -8, -6, -11, -45, 0, 7, -7, 19, 72, 16, -10, -7, 3},
    {-77, 27, 2, 9, -8, 0, 2, -27, -49, -21, -45, -9, 2, 10, -18, 23, -9, 14, -15, 16, 2, 5, -8, 0, -13, 36, 0, 0, -22, 7},
    {-28, 36, 0, 16, -15, -20, 0, -10, -39, -22, -37, -12, 28, -8, -1, 1, -8, 4, -5, 16, -1, 11, -4, 3, -6, 47, 2, -16, -4, 3},
    {12, -21, -28, -19, -23, -25, -24, 7, 13, 6, 27, 6, 23, 7, 3, 15, 0, -6, -4, 5, 5, -6, 16, 4, 4, -24, -43, -122, -6, 5},
    {-6, 2, 23, -4, 6, -15, 9, 3, 11, 20, -5, -5, -4, 18, 0, 1, -1, 13, 35, 7, 17, 11, -29, -4, -29, 20, 10, -4, 0, -3},
    {3, -15, -3, -80, -14, 16, -34, -10, -4, -5, -13, 5, -5, -54, 3, -13, 0, -24, 21, -7, -7, 1, 14, 1, 18, 4, -22, -4, 38, 6},
    {9, 12, -46, -6, -15, 11, -17, -11, 16, 16, 16, -10, 17, -15, 11, 11, -23, -3, -25, 4, 11, -12, 22, -4, 3, -8, -16, -50, 4, 10},
  },
};

int twoB[8][32] = {
  {3803, 2364, 1945, -4624, -1911, 4957, 1166, -4157, 3776, -462, -2481, 2682, 3638, -365, -2191, -1361, 2157, -2267, -3785, 90, -8542, -1123, 466, 2176, -1957, 2694, 3290, -482, 886, -2560, -640, -3250},
  {340, -1489, -39, -961, 372, -911, -6220, -5934, 4949, -59, 573, 199, -197, 2394, -2077, -599, -246, 1268, 2737, -3395, -1553, -912, 42, -2181, -2390, -793, 3742, -1131, -352, -1519, 4041, -260},
  {3976, -1634, 2505, -298, -2681, 1692, -1733, -3508, -1755, 178, -2853, -1543, -2057, -1025, 486, 2838, -732, -3475, 1415, -2133, -305, -3331, -4645, -2109, -3962, -68, 3442, -2423, -3291, -1108, 1520, 206},
  {489, -826, -1406, -1839, -1488, -2572, -2108, -1535, -1646, 3125, -2253, -1257, -751, 1977, -2751, 483, 1013, -2017, 1326, 426, -1965, -1204, -7430, 376, 664, 2431, 496, -2127, 1927, 59, 351, -2666},
  {1541, -270, -199, -1233, -1473, 366, -253, -3106, 4482, 1346, 1214, 3282, 3694, 2997, -1397, -5911, -534, -3049, -1838, -712, -404, 670, -1508, -2607, -1608, 2845, -419, -1244, 0, -2256, 835, -4830},
  {529, -3651, 4100, -4860, -1831, -3439, -4014, -5085, -311, -2513, -10, -1548, -1002, -1591, -4059, -4605, -1019, -1086, -1293, -7977, -2531, 737, -2066, -2225, -3553, 2222, -3959, -1108, 1344, -2137, -1189, -2729},
  {2479, 1478, 1709, -4086, -2979, -2510, -5124, -3631, -1866, -2388, -1190, 2017, -317, -6818, -326, -3171, 258, -1091, 2053, -4457, -2985, 2333, -1962, -3409, 94, 3945, 1499, 2, 3898, -273, -550, -3722},
  {1108, -1230, 1541, -2172, -2524, -1560, -396, -1793, -4694, -1913, -1528, 1621, -1658, 240, -852, -4946, -418, -3897, -2278, 516, -944, 3009, 2053, -783, -3874, -2959, 789, 2322, 995, -3915, 1789, -1853},
};


TUNE(SetRange(-127, 127), twoW[0], SetRange(-20000, 20000), twoB[0]);


// Futility margin
Value futility_margin(Depth d, bool noTtCutNode, bool improving, bool oppWorsening) {
    Value futilityMult       = 109 - 40 * noTtCutNode;
    Value improvingDeduction = 59 * improving * futilityMult / 32;
    Value worseningDeduction = 328 * oppWorsening * futilityMult / 1024;

    return futilityMult * d - improvingDeduction - worseningDeduction;
}

constexpr int futility_move_count(bool improving, Depth depth) {
    return improving ? (3 + depth * depth) : (3 + depth * depth) / 2;
}

// Add correctionHistory value to raw staticEval and guarantee evaluation does not hit the tablebase range
Value to_corrected_static_eval(Value v, const Worker& w, const Position& pos) {
    auto cv = w.correctionHistory[pos.side_to_move()][pawn_structure_index<Correction>(pos)];
    v += cv / 10;
    return std::clamp(v, VALUE_TB_LOSS_IN_MAX_PLY + 1, VALUE_TB_WIN_IN_MAX_PLY - 1);
}

// History and stats update bonus, based on depth
int stat_bonus(Depth d) { return std::clamp(186 * d - 285, 20, 1524); }

// History and stats update malus, based on depth
int stat_malus(Depth d) { return (d < 4 ? 707 * d - 260 : 2073); }

// Add a small random component to draw evaluations to avoid 3-fold blindness
Value value_draw(size_t nodes) { return VALUE_DRAW - 1 + Value(nodes & 0x2); }

// Skill structure is used to implement strength limit. If we have a UCI_Elo,
// we convert it to an appropriate skill level, anchored to the Stash engine.
// This method is based on a fit of the Elo results for games played between
// Stockfish at various skill levels and various versions of the Stash engine.
// Skill 0 .. 19 now covers CCRL Blitz Elo from 1320 to 3190, approximately
// Reference: https://github.com/vondele/Stockfish/commit/a08b8d4e9711c2
struct Skill {
    Skill(int skill_level, int uci_elo) {
        if (uci_elo)
        {
            double e = double(uci_elo - 1320) / (3190 - 1320);
            level = std::clamp((((37.2473 * e - 40.8525) * e + 22.2943) * e - 0.311438), 0.0, 19.0);
        }
        else
            level = double(skill_level);
    }
    bool enabled() const { return level < 20.0; }
    bool time_to_pick(Depth depth) const { return depth == 1 + int(level); }
    Move pick_best(const RootMoves&, size_t multiPV);

    double level;
    Move   best = Move::none();
};

Value value_to_tt(Value v, int ply);
Value value_from_tt(Value v, int ply, int r50c);
void  update_pv(Move* pv, Move move, const Move* childPv);
void  update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus);
void  update_refutations(const Position& pos, Stack* ss, Search::Worker& workerThread, Move move);
void  update_quiet_histories(
   const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus);
void update_quiet_stats(
  const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus);
void update_all_stats(const Position& pos,
                      Stack*          ss,
                      Search::Worker& workerThread,
                      Move            bestMove,
                      Value           bestValue,
                      Value           beta,
                      Square          prevSq,
                      Move*           quietsSearched,
                      int             quietCount,
                      Move*           capturesSearched,
                      int             captureCount,
                      Depth           depth);

}  // namespace

Search::Worker::Worker(SharedState&                    sharedState,
                       std::unique_ptr<ISearchManager> sm,
                       size_t                          threadId,
                       NumaReplicatedAccessToken       token) :
    // Unpack the SharedState struct into member variables
    threadIdx(threadId),
    numaAccessToken(token),
    manager(std::move(sm)),
    options(sharedState.options),
    threads(sharedState.threads),
    tt(sharedState.tt),
    networks(sharedState.networks),
    refreshTable(networks[token]) {
    clear();
}

void Search::Worker::start_searching() {

    /*
    for (size_t j = 0; j < 8; ++j)
    {
        for (size_t i = 0; i < 32; ++i)
        { 
            networks->big.network[j].fc_2.weights[i] = ow[(j * 32) + i]; 
        }
    }

    for (size_t j = 0; j < 8; ++j)
    { 
        networks->big.network[j].fc_2.biases[0] = ob[j]; 
    }
    */

    for (size_t i = 0; i < 8; ++i)
        for (size_t j = 0; j < 32; ++j)
            for (size_t k = 0; k < 30; ++k)
                networks->big.network[i].fc_1.weights[k + j*32] = twoW[i][j][k];

    for (size_t i = 0; i < 8; ++i)
        for (size_t j = 0; j < 32; ++j)
            networks->big.network[i].fc_1.biases[j] = twoB[i][j];

    /*
    for (size_t j = 0; j < 8; ++j)
    {
        for (size_t i = 0; i < 16; ++i)
        { 
            networks->big.network[j].fc_0.biases[i] = oneb[(j * 16) + i]; 
        }
    }
    */


    // Non-main threads go directly to iterative_deepening()
    if (!is_mainthread())
    {
        iterative_deepening();
        return;
    }

    main_manager()->tm.init(limits, rootPos.side_to_move(), rootPos.game_ply(), options,
                            main_manager()->originalTimeAdjust);
    tt.new_search();

    if (rootMoves.empty())
    {
        rootMoves.emplace_back(Move::none());
        main_manager()->updates.onUpdateNoMoves(
          {0, {rootPos.checkers() ? -VALUE_MATE : VALUE_DRAW, rootPos}});
    }
    else
    {
        threads.start_searching();  // start non-main threads
        iterative_deepening();      // main thread start searching
    }

    // When we reach the maximum depth, we can arrive here without a raise of
    // threads.stop. However, if we are pondering or in an infinite search,
    // the UCI protocol states that we shouldn't print the best move before the
    // GUI sends a "stop" or "ponderhit" command. We therefore simply wait here
    // until the GUI sends one of those commands.
    while (!threads.stop && (main_manager()->ponder || limits.infinite))
    {}  // Busy wait for a stop or a ponder reset

    // Stop the threads if not already stopped (also raise the stop if
    // "ponderhit" just reset threads.ponder).
    threads.stop = true;

    // Wait until all threads have finished
    threads.wait_for_search_finished();

    // When playing in 'nodes as time' mode, subtract the searched nodes from
    // the available ones before exiting.
    if (limits.npmsec)
        main_manager()->tm.advance_nodes_time(threads.nodes_searched()
                                              - limits.inc[rootPos.side_to_move()]);

    Worker* bestThread = this;
    Skill   skill =
      Skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    if (int(options["MultiPV"]) == 1 && !limits.depth && !limits.mate && !skill.enabled()
        && rootMoves[0].pv[0] != Move::none())
        bestThread = threads.get_best_thread()->worker.get();

    main_manager()->bestPreviousScore        = bestThread->rootMoves[0].score;
    main_manager()->bestPreviousAverageScore = bestThread->rootMoves[0].averageScore;

    // Send again PV info if we have a new best thread
    if (bestThread != this)
        main_manager()->pv(*bestThread, threads, tt, bestThread->completedDepth);

    std::string ponder;

    if (bestThread->rootMoves[0].pv.size() > 1
        || bestThread->rootMoves[0].extract_ponder_from_tt(tt, rootPos))
        ponder = UCIEngine::move(bestThread->rootMoves[0].pv[1], rootPos.is_chess960());

    auto bestmove = UCIEngine::move(bestThread->rootMoves[0].pv[0], rootPos.is_chess960());
    main_manager()->updates.onBestmove(bestmove, ponder);
}

// Main iterative deepening loop. It calls search()
// repeatedly with increasing depth until the allocated thinking time has been
// consumed, the user stops the search, or the maximum search depth is reached.
void Search::Worker::iterative_deepening() {

    SearchManager* mainThread = (is_mainthread() ? main_manager() : nullptr);

    Move pv[MAX_PLY + 1];

    Depth lastBestMoveDepth = 0;
    Value lastBestScore     = -VALUE_INFINITE;
    auto  lastBestPV        = std::vector{Move::none()};

    Value  alpha, beta;
    Value  bestValue     = -VALUE_INFINITE;
    Color  us            = rootPos.side_to_move();
    double timeReduction = 1, totBestMoveChanges = 0;
    int    delta, iterIdx                        = 0;

    // Allocate stack with extra size to allow access from (ss - 7) to (ss + 2):
    // (ss - 7) is needed for update_continuation_histories(ss - 1) which accesses (ss - 6),
    // (ss + 2) is needed for initialization of cutOffCnt and killers.
    Stack  stack[MAX_PLY + 10] = {};
    Stack* ss                  = stack + 7;

    for (int i = 7; i > 0; --i)
    {
        (ss - i)->continuationHistory =
          &this->continuationHistory[0][0][NO_PIECE][0];  // Use as a sentinel
        (ss - i)->staticEval = VALUE_NONE;
    }

    for (int i = 0; i <= MAX_PLY + 2; ++i)
        (ss + i)->ply = i;

    ss->pv = pv;

    if (mainThread)
    {
        if (mainThread->bestPreviousScore == VALUE_INFINITE)
            mainThread->iterValue.fill(VALUE_ZERO);
        else
            mainThread->iterValue.fill(mainThread->bestPreviousScore);
    }

    size_t multiPV = size_t(options["MultiPV"]);
    Skill skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    // When playing with strength handicap enable MultiPV search that we will
    // use behind-the-scenes to retrieve a set of possible moves.
    if (skill.enabled())
        multiPV = std::max(multiPV, size_t(4));

    multiPV = std::min(multiPV, rootMoves.size());

    int searchAgainCounter = 0;

    // Iterative deepening loop until requested to stop or the target depth is reached
    while (++rootDepth < MAX_PLY && !threads.stop
           && !(limits.depth && mainThread && rootDepth > limits.depth))
    {
        // Age out PV variability metric
        if (mainThread)
            totBestMoveChanges /= 2;

        // Save the last iteration's scores before the first PV line is searched and
        // all the move scores except the (new) PV are set to -VALUE_INFINITE.
        for (RootMove& rm : rootMoves)
            rm.previousScore = rm.score;

        size_t pvFirst = 0;
        pvLast         = 0;

        if (!threads.increaseDepth)
            searchAgainCounter++;

        // MultiPV loop. We perform a full root search for each PV line
        for (pvIdx = 0; pvIdx < multiPV; ++pvIdx)
        {
            if (pvIdx == pvLast)
            {
                pvFirst = pvLast;
                for (pvLast++; pvLast < rootMoves.size(); pvLast++)
                    if (rootMoves[pvLast].tbRank != rootMoves[pvFirst].tbRank)
                        break;
            }

            // Reset UCI info selDepth for each depth and each PV line
            selDepth = 0;

            // Reset aspiration window starting size
            Value avg = rootMoves[pvIdx].averageScore;
            delta     = 9 + avg * avg / 10182;
            alpha     = std::max(avg - delta, -VALUE_INFINITE);
            beta      = std::min(avg + delta, VALUE_INFINITE);

            // Adjust optimism based on root move's averageScore (~4 Elo)
            optimism[us]  = 127 * avg / (std::abs(avg) + 86);
            optimism[~us] = -optimism[us];

            // Start with a small aspiration window and, in the case of a fail
            // high/low, re-search with a bigger window until we don't fail
            // high/low anymore.
            int failedHighCnt = 0;
            while (true)
            {
                // Adjust the effective depth searched, but ensure at least one effective increment
                // for every four searchAgain steps (see issue #2717).
                Depth adjustedDepth =
                  std::max(1, rootDepth - failedHighCnt - 3 * (searchAgainCounter + 1) / 4);
                rootDelta = beta - alpha;
                bestValue = search<Root>(rootPos, ss, alpha, beta, adjustedDepth, false);

                // Bring the best move to the front. It is critical that sorting
                // is done with a stable algorithm because all the values but the
                // first and eventually the new best one is set to -VALUE_INFINITE
                // and we want to keep the same order for all the moves except the
                // new PV that goes to the front. Note that in the case of MultiPV
                // search the already searched PV lines are preserved.
                std::stable_sort(rootMoves.begin() + pvIdx, rootMoves.begin() + pvLast);

                // If search has been stopped, we break immediately. Sorting is
                // safe because RootMoves is still valid, although it refers to
                // the previous iteration.
                if (threads.stop)
                    break;

                // When failing high/low give some update (without cluttering
                // the UI) before a re-search.
                if (mainThread && multiPV == 1 && (bestValue <= alpha || bestValue >= beta)
                    && elapsed_time() > 3000)
                    main_manager()->pv(*this, threads, tt, rootDepth);

                // In case of failing low/high increase aspiration window and
                // re-search, otherwise exit the loop.
                if (bestValue <= alpha)
                {
                    beta  = (alpha + beta) / 2;
                    alpha = std::max(bestValue - delta, -VALUE_INFINITE);

                    failedHighCnt = 0;
                    if (mainThread)
                        mainThread->stopOnPonderhit = false;
                }
                else if (bestValue >= beta)
                {
                    beta = std::min(bestValue + delta, VALUE_INFINITE);
                    ++failedHighCnt;
                }
                else
                    break;

                delta += delta / 3;

                assert(alpha >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
            }

            // Sort the PV lines searched so far and update the GUI
            std::stable_sort(rootMoves.begin() + pvFirst, rootMoves.begin() + pvIdx + 1);

            if (mainThread
                && (threads.stop || pvIdx + 1 == multiPV || elapsed_time() > 3000)
                // A thread that aborted search can have mated-in/TB-loss PV and score
                // that cannot be trusted, i.e. it can be delayed or refuted if we would have
                // had time to fully search other root-moves. Thus we suppress this output and
                // below pick a proven score/PV for this thread (from the previous iteration).
                && !(threads.abortedSearch && rootMoves[0].uciScore <= VALUE_TB_LOSS_IN_MAX_PLY))
                main_manager()->pv(*this, threads, tt, rootDepth);

            if (threads.stop)
                break;
        }

        if (!threads.stop)
            completedDepth = rootDepth;

        // We make sure not to pick an unproven mated-in score,
        // in case this thread prematurely stopped search (aborted-search).
        if (threads.abortedSearch && rootMoves[0].score != -VALUE_INFINITE
            && rootMoves[0].score <= VALUE_TB_LOSS_IN_MAX_PLY)
        {
            // Bring the last best move to the front for best thread selection.
            Utility::move_to_front(rootMoves, [&lastBestPV = std::as_const(lastBestPV)](
                                                const auto& rm) { return rm == lastBestPV[0]; });
            rootMoves[0].pv    = lastBestPV;
            rootMoves[0].score = rootMoves[0].uciScore = lastBestScore;
        }
        else if (rootMoves[0].pv[0] != lastBestPV[0])
        {
            lastBestPV        = rootMoves[0].pv;
            lastBestScore     = rootMoves[0].score;
            lastBestMoveDepth = rootDepth;
        }

        if (!mainThread)
            continue;

        // Have we found a "mate in x"?
        if (limits.mate && rootMoves[0].score == rootMoves[0].uciScore
            && ((rootMoves[0].score >= VALUE_MATE_IN_MAX_PLY
                 && VALUE_MATE - rootMoves[0].score <= 2 * limits.mate)
                || (rootMoves[0].score != -VALUE_INFINITE
                    && rootMoves[0].score <= VALUE_MATED_IN_MAX_PLY
                    && VALUE_MATE + rootMoves[0].score <= 2 * limits.mate)))
            threads.stop = true;

        // If the skill level is enabled and time is up, pick a sub-optimal best move
        if (skill.enabled() && skill.time_to_pick(rootDepth))
            skill.pick_best(rootMoves, multiPV);

        // Use part of the gained time from a previous stable move for the current move
        for (auto&& th : threads)
        {
            totBestMoveChanges += th->worker->bestMoveChanges;
            th->worker->bestMoveChanges = 0;
        }

        // Do we have time for the next iteration? Can we stop searching now?
        if (limits.use_time_management() && !threads.stop && !mainThread->stopOnPonderhit)
        {
            int nodesEffort = rootMoves[0].effort * 100 / std::max(size_t(1), size_t(nodes));

            double fallingEval = (1067 + 223 * (mainThread->bestPreviousAverageScore - bestValue)
                                  + 97 * (mainThread->iterValue[iterIdx] - bestValue))
                               / 10000.0;
            fallingEval = std::clamp(fallingEval, 0.580, 1.667);

            // If the bestMove is stable over several iterations, reduce time accordingly
            timeReduction    = lastBestMoveDepth + 8 < completedDepth ? 1.495 : 0.687;
            double reduction = (1.48 + mainThread->previousTimeReduction) / (2.17 * timeReduction);
            double bestMoveInstability = 1 + 1.88 * totBestMoveChanges / threads.size();
            int    el                  = std::clamp((bestValue + 750) / 150, 0, 9);
            double recapture           = limits.capSq == rootMoves[0].pv[0].to_sq() ? 0.955 : 1.005;

            double totalTime = mainThread->tm.optimum() * fallingEval * reduction
                             * bestMoveInstability * EvalLevel[el] * recapture;

            // Cap used time in case of a single legal move for a better viewer experience
            if (rootMoves.size() == 1)
                totalTime = std::min(500.0, totalTime);

            auto elapsedTime = elapsed();

            if (completedDepth >= 10 && nodesEffort >= 97 && elapsedTime > totalTime * 0.739
                && !mainThread->ponder)
                threads.stop = true;

            // Stop the search if we have exceeded the totalTime
            if (elapsedTime > totalTime)
            {
                // If we are allowed to ponder do not stop the search now but
                // keep pondering until the GUI sends "ponderhit" or "stop".
                if (mainThread->ponder)
                    mainThread->stopOnPonderhit = true;
                else
                    threads.stop = true;
            }
            else
                threads.increaseDepth = mainThread->ponder || elapsedTime <= totalTime * 0.506;
        }

        mainThread->iterValue[iterIdx] = bestValue;
        iterIdx                        = (iterIdx + 1) & 3;
    }

    if (!mainThread)
        return;

    mainThread->previousTimeReduction = timeReduction;

    // If the skill level is enabled, swap the best PV line with the sub-optimal one
    if (skill.enabled())
        std::swap(rootMoves[0],
                  *std::find(rootMoves.begin(), rootMoves.end(),
                             skill.best ? skill.best : skill.pick_best(rootMoves, multiPV)));
}

void Search::Worker::clear() {
    counterMoves.fill(Move::none());
    mainHistory.fill(0);
    captureHistory.fill(0);
    pawnHistory.fill(-1193);
    correctionHistory.fill(0);

    for (bool inCheck : {false, true})
        for (StatsType c : {NoCaptures, Captures})
            for (auto& to : continuationHistory[inCheck][c])
                for (auto& h : to)
                    h->fill(-56);

    for (size_t i = 1; i < reductions.size(); ++i)
        reductions[i] = int((19.26 + std::log(size_t(options["Threads"])) / 2) * std::log(i));

    refreshTable.clear(networks[numaAccessToken]);
}


// Main search function for both PV and non-PV nodes.
template<NodeType nodeType>
Value Search::Worker::search(
  Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {

    constexpr bool PvNode   = nodeType != NonPV;
    constexpr bool rootNode = nodeType == Root;

    // Dive into quiescence search when the depth reaches zero
    if (depth <= 0)
        return qsearch < PvNode ? PV : NonPV > (pos, ss, alpha, beta);

    // Limit the depth if extensions made it too large
    depth = std::min(depth, MAX_PLY - 1);

    // Check if we have an upcoming move that draws by repetition, or
    // if the opponent had an alternative move earlier to this position.
    if (!rootNode && alpha < VALUE_DRAW && pos.has_game_cycle(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    assert(-VALUE_INFINITE <= alpha && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(0 < depth && depth < MAX_PLY);
    assert(!(PvNode && cutNode));

    Move      pv[MAX_PLY + 1], capturesSearched[32], quietsSearched[32];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, excludedMove, bestMove;
    Depth extension, newDepth;
    Value bestValue, value, eval, maxValue, probCutBeta, singularValue;
    bool  givesCheck, improving, priorCapture, opponentWorsening;
    bool  capture, moveCountPruning, ttCapture;
    Piece movedPiece;
    int   moveCount, captureCount, quietCount;
    Bound singularBound;

    // Step 1. Initialize node
    Worker* thisThread = this;
    ss->inCheck        = pos.checkers();
    priorCapture       = pos.captured_piece();
    Color us           = pos.side_to_move();
    moveCount = captureCount = quietCount = ss->moveCount = 0;
    bestValue                                             = -VALUE_INFINITE;
    maxValue                                              = VALUE_INFINITE;

    // Check for the available remaining time
    if (is_mainthread())
        main_manager()->check_time(*thisThread);

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    if (!rootNode)
    {
        // Step 2. Check for aborted search and immediate draw
        if (threads.stop.load(std::memory_order_relaxed) || pos.is_draw(ss->ply)
            || ss->ply >= MAX_PLY)
            return (ss->ply >= MAX_PLY && !ss->inCheck)
                   ? evaluate(networks[numaAccessToken], pos, refreshTable,
                              thisThread->optimism[us])
                   : value_draw(thisThread->nodes);

        // Step 3. Mate distance pruning. Even if we mate at the next move our score
        // would be at best mate_in(ss->ply + 1), but if alpha is already bigger because
        // a shorter mate was found upward in the tree then there is no need to search
        // because we will never beat the current alpha. Same logic but with reversed
        // signs apply also in the opposite condition of being mated instead of giving
        // mate. In this case, return a fail-high score.
        alpha = std::max(mated_in(ss->ply), alpha);
        beta  = std::min(mate_in(ss->ply + 1), beta);
        if (alpha >= beta)
            return alpha;
    }

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    bestMove             = Move::none();
    (ss + 2)->killers[0] = (ss + 2)->killers[1] = Move::none();
    (ss + 2)->cutoffCnt                         = 0;
    Square prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;
    ss->statScore = 0;

    // Step 4. Transposition table lookup.
    excludedMove                   = ss->excludedMove;
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = rootNode ? thisThread->rootMoves[thisThread->pvIdx].pv[0]
                 : ttHit    ? ttData.move
                            : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    ss->ttPv     = excludedMove ? ss->ttPv : PvNode || (ttHit && ttData.is_pv);
    ttCapture    = ttData.move && pos.capture_stage(ttData.move);

    // At this point, if excluded, skip straight to step 6, static eval. However,
    // to save indentation, we list the condition in all code between here and there.

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && !excludedMove && ttData.depth > depth - (ttData.value <= beta)
        && ttData.value != VALUE_NONE  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER)))
    {
        // If ttMove is quiet, update move sorting heuristics on TT hit (~2 Elo)
        if (ttData.move && ttData.value >= beta)
        {
            // Bonus for a quiet ttMove that fails high (~2 Elo)
            if (!ttCapture)
                update_quiet_stats(pos, ss, *this, ttData.move, stat_bonus(depth));

            // Extra penalty for early quiet moves of
            // the previous ply (~1 Elo on STC, ~2 Elo on LTC)
            if (prevSq != SQ_NONE && (ss - 1)->moveCount <= 2 && !priorCapture)
                update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                              -stat_malus(depth + 1));
        }

        // Partial workaround for the graph history interaction problem
        // For high rule50 counts don't produce transposition table cutoffs.
        if (pos.rule50_count() < 90)
            return ttData.value;
    }

    // Step 5. Tablebases probe
    if (!rootNode && !excludedMove && tbConfig.cardinality)
    {
        int piecesCount = pos.count<ALL_PIECES>();

        if (piecesCount <= tbConfig.cardinality
            && (piecesCount < tbConfig.cardinality || depth >= tbConfig.probeDepth)
            && pos.rule50_count() == 0 && !pos.can_castle(ANY_CASTLING))
        {
            TB::ProbeState err;
            TB::WDLScore   wdl = Tablebases::probe_wdl(pos, &err);

            // Force check of time on the next occasion
            if (is_mainthread())
                main_manager()->callsCnt = 0;

            if (err != TB::ProbeState::FAIL)
            {
                thisThread->tbHits.fetch_add(1, std::memory_order_relaxed);

                int drawScore = tbConfig.useRule50 ? 1 : 0;

                Value tbValue = VALUE_TB - ss->ply;

                // use the range VALUE_TB to VALUE_TB_WIN_IN_MAX_PLY to score
                value = wdl < -drawScore ? -tbValue
                      : wdl > drawScore  ? tbValue
                                         : VALUE_DRAW + 2 * wdl * drawScore;

                Bound b = wdl < -drawScore ? BOUND_UPPER
                        : wdl > drawScore  ? BOUND_LOWER
                                           : BOUND_EXACT;

                if (b == BOUND_EXACT || (b == BOUND_LOWER ? value >= beta : value <= alpha))
                {
                    ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, b,
                                   std::min(MAX_PLY - 1, depth + 6), Move::none(), VALUE_NONE,
                                   tt.generation());

                    return value;
                }

                if (PvNode)
                {
                    if (b == BOUND_LOWER)
                        bestValue = value, alpha = std::max(alpha, bestValue);
                    else
                        maxValue = value;
                }
            }
        }
    }

    // Step 6. Static evaluation of the position
    Value unadjustedStaticEval = VALUE_NONE;
    if (ss->inCheck)
    {
        // Skip early pruning when in check
        ss->staticEval = eval = VALUE_NONE;
        improving             = false;
        goto moves_loop;
    }
    else if (excludedMove)
    {
        // Providing the hint that this node's accumulator will be used often
        // brings significant Elo gain (~13 Elo).
        Eval::NNUE::hint_common_parent_position(pos, networks[numaAccessToken], refreshTable);
        unadjustedStaticEval = eval = ss->staticEval;
    }
    else if (ss->ttHit)
    {
        // Never assume anything about values stored in TT
        unadjustedStaticEval = ttData.eval;
        if (unadjustedStaticEval == VALUE_NONE)
            unadjustedStaticEval =
              evaluate(networks[numaAccessToken], pos, refreshTable, thisThread->optimism[us]);
        else if (PvNode)
            Eval::NNUE::hint_common_parent_position(pos, networks[numaAccessToken], refreshTable);

        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, *thisThread, pos);

        // ttValue can be used as a better position evaluation (~7 Elo)
        if (ttData.value != VALUE_NONE
            && (ttData.bound & (ttData.value > eval ? BOUND_LOWER : BOUND_UPPER)))
            eval = ttData.value;
    }
    else
    {
        unadjustedStaticEval =
          evaluate(networks[numaAccessToken], pos, refreshTable, thisThread->optimism[us]);
        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, *thisThread, pos);

        // Static evaluation is saved as it was before adjustment by correction history
        ttWriter.write(posKey, VALUE_NONE, ss->ttPv, BOUND_NONE, DEPTH_UNSEARCHED, Move::none(),
                       unadjustedStaticEval, tt.generation());
    }

    // Use static evaluation difference to improve quiet move ordering (~9 Elo)
    if (((ss - 1)->currentMove).is_ok() && !(ss - 1)->inCheck && !priorCapture)
    {
        int bonus = std::clamp(-10 * int((ss - 1)->staticEval + ss->staticEval), -1590, 1371) + 800;
        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()] << bonus;
        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << bonus / 2;
    }

    // Set up the improving flag, which is true if current static evaluation is
    // bigger than the previous static evaluation at our turn (if we were in
    // check at our previous move we look at static evaluation at move prior to it
    // and if we were in check at move prior to it flag is set to true) and is
    // false otherwise. The improving flag is used in various pruning heuristics.
    improving = (ss - 2)->staticEval != VALUE_NONE
                ? ss->staticEval > (ss - 2)->staticEval
                : (ss - 4)->staticEval != VALUE_NONE && ss->staticEval > (ss - 4)->staticEval;

    opponentWorsening = ss->staticEval + (ss - 1)->staticEval > 2;

    // Step 7. Razoring (~1 Elo)
    // If eval is really low check with qsearch if it can exceed alpha, if it can't,
    // return a fail low.
    if (eval < alpha - 512 - 293 * depth * depth)
    {
        value = qsearch<NonPV>(pos, ss, alpha - 1, alpha);
        if (value < alpha && std::abs(value) < VALUE_TB_WIN_IN_MAX_PLY)
            return value;
    }

    // Step 8. Futility pruning: child node (~40 Elo)
    // The depth condition is important for mate finding.
    if (!ss->ttPv && depth < 13
        && eval - futility_margin(depth, cutNode && !ss->ttHit, improving, opponentWorsening)
               - (ss - 1)->statScore / 263
             >= beta
        && eval >= beta && eval < VALUE_TB_WIN_IN_MAX_PLY && (!ttData.move || ttCapture))
        return beta > VALUE_TB_LOSS_IN_MAX_PLY ? beta + (eval - beta) / 3 : eval;

    // Step 9. Null move search with verification search (~35 Elo)
    if (!PvNode && (ss - 1)->currentMove != Move::null() && (ss - 1)->statScore < 14369
        && eval >= beta && ss->staticEval >= beta - 21 * depth + 393 && !excludedMove
        && pos.non_pawn_material(us) && ss->ply >= thisThread->nmpMinPly
        && beta > VALUE_TB_LOSS_IN_MAX_PLY)
    {
        assert(eval - beta >= 0);

        // Null move dynamic reduction based on depth and eval
        Depth R = std::min(int(eval - beta) / 197, 6) + depth / 3 + 5;

        ss->currentMove         = Move::null();
        ss->continuationHistory = &thisThread->continuationHistory[0][0][NO_PIECE][0];

        pos.do_null_move(st, tt);

        Value nullValue = -search<NonPV>(pos, ss + 1, -beta, -beta + 1, depth - R, !cutNode);

        pos.undo_null_move();

        // Do not return unproven mate or TB scores
        if (nullValue >= beta && nullValue < VALUE_TB_WIN_IN_MAX_PLY)
        {
            if (thisThread->nmpMinPly || depth < 16)
                return nullValue;

            assert(!thisThread->nmpMinPly);  // Recursive verification is not allowed

            // Do verification search at high depths, with null move pruning disabled
            // until ply exceeds nmpMinPly.
            thisThread->nmpMinPly = ss->ply + 3 * (depth - R) / 4;

            Value v = search<NonPV>(pos, ss, beta - 1, beta, depth - R, false);

            thisThread->nmpMinPly = 0;

            if (v >= beta)
                return nullValue;
        }
    }

    // Step 10. Internal iterative reductions (~9 Elo)
    // For PV nodes without a ttMove, we decrease depth.
    // Additionally, if the current position is found in the TT
    // and the stored depth in the TT is greater than or equal to
    // current search depth, we decrease search depth even further.
    if (PvNode && !ttData.move)
        depth -= 3 + (ss->ttHit && ttData.depth >= depth);

    // Use qsearch if depth <= 0.
    if (depth <= 0)
        return qsearch<PV>(pos, ss, alpha, beta);

    // For cutNodes, if depth is high enough, decrease depth by 2 if there is no ttMove, or
    // by 1 if there is a ttMove with an upper bound.
    if (cutNode && depth >= 8 && (!ttData.move || ttData.bound == BOUND_UPPER))
        depth -= 1 + !ttData.move;

    // Step 11. ProbCut (~10 Elo)
    // If we have a good enough capture (or queen promotion) and a reduced search returns a value
    // much above beta, we can (almost) safely prune the previous move.
    probCutBeta = beta + 177 - 57 * improving;
    if (
      !PvNode && depth > 3
      && std::abs(beta) < VALUE_TB_WIN_IN_MAX_PLY
      // If value from transposition table is lower than probCutBeta, don't attempt probCut
      // there and in further interactions with transposition table cutoff depth is set to depth - 3
      // because probCut search has depth set to depth - 4 but we also do a move before it
      // So effective depth is equal to depth - 3
      && !(ttData.depth >= depth - 3 && ttData.value != VALUE_NONE && ttData.value < probCutBeta))
    {
        assert(probCutBeta < VALUE_INFINITE && probCutBeta > beta);

        MovePicker mp(pos, ttData.move, probCutBeta - ss->staticEval, &thisThread->captureHistory);

        while ((move = mp.next_move()) != Move::none())
            if (move != excludedMove && pos.legal(move))
            {
                assert(pos.capture_stage(move));

                // Prefetch the TT entry for the resulting position
                prefetch(tt.first_entry(pos.key_after(move)));

                ss->currentMove = move;
                ss->continuationHistory =
                  &this
                     ->continuationHistory[ss->inCheck][true][pos.moved_piece(move)][move.to_sq()];

                thisThread->nodes.fetch_add(1, std::memory_order_relaxed);
                pos.do_move(move, st);

                // Perform a preliminary qsearch to verify that the move holds
                value = -qsearch<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1);

                // If the qsearch held, perform the regular search
                if (value >= probCutBeta)
                    value = -search<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1, depth - 4,
                                           !cutNode);

                pos.undo_move(move);

                if (value >= probCutBeta)
                {
                    // Save ProbCut data into transposition table
                    ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, BOUND_LOWER,
                                   depth - 3, move, unadjustedStaticEval, tt.generation());
                    return std::abs(value) < VALUE_TB_WIN_IN_MAX_PLY ? value - (probCutBeta - beta)
                                                                     : value;
                }
            }

        Eval::NNUE::hint_common_parent_position(pos, networks[numaAccessToken], refreshTable);
    }

moves_loop:  // When in check, search starts here

    // Step 12. A small Probcut idea, when we are in check (~4 Elo)
    probCutBeta = beta + 388;
    if (ss->inCheck && !PvNode && ttCapture && (ttData.bound & BOUND_LOWER)
        && ttData.depth >= depth - 4 && ttData.value >= probCutBeta
        && std::abs(ttData.value) < VALUE_TB_WIN_IN_MAX_PLY
        && std::abs(beta) < VALUE_TB_WIN_IN_MAX_PLY)
        return probCutBeta;

    const PieceToHistory* contHist[] = {(ss - 1)->continuationHistory,
                                        (ss - 2)->continuationHistory,
                                        (ss - 3)->continuationHistory,
                                        (ss - 4)->continuationHistory,
                                        nullptr,
                                        (ss - 6)->continuationHistory};

    Move countermove =
      prevSq != SQ_NONE ? thisThread->counterMoves[pos.piece_on(prevSq)][prevSq] : Move::none();

    MovePicker mp(pos, ttData.move, depth, &thisThread->mainHistory, &thisThread->captureHistory,
                  contHist, &thisThread->pawnHistory, countermove, ss->killers);

    value            = bestValue;
    moveCountPruning = false;
    singularValue    = VALUE_INFINITE;
    singularBound    = BOUND_NONE;

    // Step 13. Loop through all pseudo-legal moves until no moves remain
    // or a beta cutoff occurs.
    while ((move = mp.next_move(moveCountPruning)) != Move::none())
    {
        assert(move.is_ok());

        if (move == excludedMove)
            continue;

        // Check for legality
        if (!pos.legal(move))
            continue;

        // At root obey the "searchmoves" option and skip moves not listed in Root
        // Move List. In MultiPV mode we also skip PV moves that have been already
        // searched and those of lower "TB rank" if we are in a TB root position.
        if (rootNode
            && !std::count(thisThread->rootMoves.begin() + thisThread->pvIdx,
                           thisThread->rootMoves.begin() + thisThread->pvLast, move))
            continue;

        ss->moveCount = ++moveCount;

        if (rootNode && is_mainthread() && elapsed_time() > 3000)
        {
            main_manager()->updates.onIter(
              {depth, UCIEngine::move(move, pos.is_chess960()), moveCount + thisThread->pvIdx});
        }
        if (PvNode)
            (ss + 1)->pv = nullptr;

        extension  = 0;
        capture    = pos.capture_stage(move);
        movedPiece = pos.moved_piece(move);
        givesCheck = pos.gives_check(move);

        // Calculate new depth for this move
        newDepth = depth - 1;

        int delta = beta - alpha;

        Depth r = reduction(improving, depth, moveCount, delta);

        // Step 14. Pruning at shallow depth (~120 Elo).
        // Depth conditions are important for mate finding.
        if (!rootNode && pos.non_pawn_material(us) && bestValue > VALUE_TB_LOSS_IN_MAX_PLY)
        {
            // Skip quiet moves if movecount exceeds our FutilityMoveCount threshold (~8 Elo)
            moveCountPruning =
              moveCount >= futility_move_count(improving, depth)
                             - (singularBound == BOUND_UPPER && singularValue < alpha - 50);

            // Reduced depth of the next LMR search
            int lmrDepth = newDepth - r;

            if (capture || givesCheck)
            {
                Piece capturedPiece = pos.piece_on(move.to_sq());
                int   captHist =
                  thisThread->captureHistory[movedPiece][move.to_sq()][type_of(capturedPiece)];

                // Futility pruning for captures (~2 Elo)
                if (!givesCheck && lmrDepth < 7 && !ss->inCheck)
                {
                    Value futilityValue = ss->staticEval + 287 + 248 * lmrDepth
                                        + PieceValue[capturedPiece] + captHist / 7;
                    if (futilityValue <= alpha)
                        continue;
                }

                // SEE based pruning for captures and checks (~11 Elo)
                int seeHist = std::clamp(captHist / 32, -180 * depth, 163 * depth);
                if (!pos.see_ge(move, -160 * depth - seeHist))
                    continue;
            }
            else
            {
                int history =
                  (*contHist[0])[movedPiece][move.to_sq()]
                  + (*contHist[1])[movedPiece][move.to_sq()]
                  + thisThread->pawnHistory[pawn_structure_index(pos)][movedPiece][move.to_sq()];

                // Continuation history based pruning (~2 Elo)
                if (lmrDepth < 6 && history < -4151 * depth)
                    continue;

                history += 2 * thisThread->mainHistory[us][move.from_to()];

                lmrDepth += history / 3678;

                Value futilityValue =
                  ss->staticEval + (bestValue < ss->staticEval - 51 ? 138 : 54) + 140 * lmrDepth;

                // Futility pruning: parent node (~13 Elo)
                if (!ss->inCheck && lmrDepth < 12 && futilityValue <= alpha)
                {
                    if (bestValue <= futilityValue && std::abs(bestValue) < VALUE_TB_WIN_IN_MAX_PLY
                        && futilityValue < VALUE_TB_WIN_IN_MAX_PLY)
                        bestValue = (bestValue + futilityValue * 3) / 4;
                    continue;
                }

                lmrDepth = std::max(lmrDepth, 0);

                // Prune moves with negative SEE (~4 Elo)
                if (!pos.see_ge(move, -24 * lmrDepth * lmrDepth))
                    continue;
            }
        }

        // Step 15. Extensions (~100 Elo)
        // We take care to not overdo to avoid search getting stuck.
        if (ss->ply < thisThread->rootDepth * 2)
        {
            // Singular extension search (~94 Elo). If all moves but one fail low on a
            // search of (alpha-s, beta-s), and just one fails high on (alpha, beta),
            // then that move is singular and should be extended. To verify this we do
            // a reduced search on the position excluding the ttMove and if the result
            // is lower than ttValue minus a margin, then we will extend the ttMove.
            // Recursive singular search is avoided.

            // Note: the depth margin and singularBeta margin are known for having non-linear
            // scaling. Their values are optimized to time controls of 180+1.8 and longer
            // so changing them requires tests at these types of time controls.
            // Generally, higher singularBeta (i.e closer to ttValue) and lower extension
            // margins scale well.

            if (!rootNode && move == ttData.move && !excludedMove
                && depth >= 4 - (thisThread->completedDepth > 35) + ss->ttPv
                && std::abs(ttData.value) < VALUE_TB_WIN_IN_MAX_PLY && (ttData.bound & BOUND_LOWER)
                && ttData.depth >= depth - 3)
            {
                Value singularBeta  = ttData.value - (52 + 80 * (ss->ttPv && !PvNode)) * depth / 64;
                Depth singularDepth = newDepth / 2;

                ss->excludedMove = move;
                value            = singularValue =
                  search<NonPV>(pos, ss, singularBeta - 1, singularBeta, singularDepth, cutNode);
                singularBound    = singularValue >= singularBeta ? BOUND_LOWER : BOUND_UPPER;
                ss->excludedMove = Move::none();

                if (value < singularBeta)
                {
                    int doubleMargin = 290 * PvNode - 200 * !ttCapture;
                    int tripleMargin = 107 + 247 * PvNode - 278 * !ttCapture + 99 * ss->ttPv;

                    extension = 1 + (value < singularBeta - doubleMargin)
                              + (value < singularBeta - tripleMargin);

                    depth += ((!PvNode) && (depth < 18));
                }

                // Multi-cut pruning
                // Our ttMove is assumed to fail high based on the bound of the TT entry,
                // and if after excluding the ttMove with a reduced search we fail high over the original beta,
                // we assume this expected cut-node is not singular (multiple moves fail high),
                // and we can prune the whole subtree by returning a softbound.
                else if (singularBeta >= beta)
                    return singularBeta;

                // Negative extensions
                // If other moves failed high over (ttValue - margin) without the ttMove on a reduced search,
                // but we cannot do multi-cut because (ttValue - margin) is lower than the original beta,
                // we do not know if the ttMove is singular or can do a multi-cut,
                // so we reduce the ttMove in favor of other moves based on some conditions:

                // If the ttMove is assumed to fail high over current beta (~7 Elo)
                else if (ttData.value >= beta)
                    extension = -3;

                // If we are on a cutNode but the ttMove is not assumed to fail high over current beta (~1 Elo)
                else if (cutNode)
                    extension = -2;
            }

            // Extension for capturing the previous moved piece (~0 Elo on STC, ~1 Elo on LTC)
            else if (PvNode && move.to_sq() == prevSq
                     && thisThread->captureHistory[movedPiece][move.to_sq()]
                                                  [type_of(pos.piece_on(move.to_sq()))]
                          > 3922)
                extension = 1;
        }

        // Add extension to new depth
        newDepth += extension;

        // Speculative prefetch as early as possible
        prefetch(tt.first_entry(pos.key_after(move)));

        // Update the current move (this must be done after singular extension search)
        ss->currentMove = move;
        ss->continuationHistory =
          &thisThread->continuationHistory[ss->inCheck][capture][movedPiece][move.to_sq()];

        uint64_t nodeCount = rootNode ? uint64_t(nodes) : 0;

        // Step 16. Make the move
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);
        pos.do_move(move, st, givesCheck);

        // These reduction adjustments have proven non-linear scaling.
        // They are optimized to time controls of 180 + 1.8 and longer so
        // changing them or adding conditions that are similar
        // requires tests at these types of time controls.

        // Decrease reduction if position is or has been on the PV (~7 Elo)
        if (ss->ttPv)
            r -= 1 + (ttData.value > alpha) + (ttData.depth >= depth)
               - (PvNode && ttData.value < alpha && ttData.depth >= depth);

        // Decrease reduction for PvNodes (~0 Elo on STC, ~2 Elo on LTC)
        if (PvNode)
            r--;

        // These reduction adjustments have no proven non-linear scaling.

        // Increase reduction for cut nodes (~4 Elo)
        if (cutNode)
            r += 2 - (ttData.depth >= depth && ss->ttPv)
               + (!ss->ttPv && move != ttData.move && move != ss->killers[0]);

        // Increase reduction if ttMove is a capture (~3 Elo)
        if (ttCapture)
            r++;

        // Increase reduction if next ply has a lot of fail high (~5 Elo)
        if ((ss + 1)->cutoffCnt > 3)
            r++;

        // For first picked move (ttMove) reduce reduction
        // but never allow it to go below 0 (~3 Elo)
        else if (move == ttData.move)
            r = std::max(0, r - 2);

        ss->statScore = 2 * thisThread->mainHistory[us][move.from_to()]
                      + (*contHist[0])[movedPiece][move.to_sq()]
                      + (*contHist[1])[movedPiece][move.to_sq()] - 4747;

        // Decrease/increase reduction for moves with a good/bad history (~8 Elo)
        r -= ss->statScore / 11125;

        // Step 17. Late moves reduction / extension (LMR, ~117 Elo)
        if (depth >= 2 && moveCount > 1 + rootNode)
        {
            // In general we want to cap the LMR depth search at newDepth, but when
            // reduction is negative, we allow this move a limited search extension
            // beyond the first move depth.
            // To prevent problems when the max value is less than the min value,
            // std::clamp has been replaced by a more robust implementation.
            Depth d = std::max(1, std::min(newDepth - r, newDepth + 1));

            value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, d, true);

            // Do a full-depth search when reduced LMR search fails high
            if (value > alpha && d < newDepth)
            {
                // Adjust full-depth search based on LMR results - if the result
                // was good enough search deeper, if it was bad enough search shallower.
                const bool doDeeperSearch    = value > (bestValue + 35 + 2 * newDepth);  // (~1 Elo)
                const bool doShallowerSearch = value < bestValue + newDepth;             // (~2 Elo)

                newDepth += doDeeperSearch - doShallowerSearch;

                if (newDepth > d)
                    value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, newDepth, !cutNode);

                // Post LMR continuation history updates (~1 Elo)
                int bonus = value <= alpha ? -stat_malus(newDepth)
                          : value >= beta  ? stat_bonus(newDepth)
                                           : 0;

                update_continuation_histories(ss, movedPiece, move.to_sq(), bonus);
            }
        }

        // Step 18. Full-depth search when LMR is skipped
        else if (!PvNode || moveCount > 1)
        {
            // Increase reduction if ttMove is not present (~6 Elo)
            if (!ttData.move)
                r += 2;

            // Note that if expected reduction is high, we reduce search depth by 1 here (~9 Elo)
            value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, newDepth - (r > 3), !cutNode);
        }

        // For PV nodes only, do a full PV search on the first move or after a fail high,
        // otherwise let the parent node fail low with value <= alpha and try another move.
        if (PvNode && (moveCount == 1 || value > alpha))
        {
            (ss + 1)->pv    = pv;
            (ss + 1)->pv[0] = Move::none();

            value = -search<PV>(pos, ss + 1, -beta, -alpha, newDepth, false);
        }

        // Step 19. Undo move
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 20. Check for a new best move
        // Finished searching the move. If a stop occurred, the return value of
        // the search cannot be trusted, and we return immediately without
        // updating best move, PV and TT.
        if (threads.stop.load(std::memory_order_relaxed))
            return VALUE_ZERO;

        if (rootNode)
        {
            RootMove& rm =
              *std::find(thisThread->rootMoves.begin(), thisThread->rootMoves.end(), move);

            rm.effort += nodes - nodeCount;

            rm.averageScore =
              rm.averageScore != -VALUE_INFINITE ? (2 * value + rm.averageScore) / 3 : value;

            // PV move or new best move?
            if (moveCount == 1 || value > alpha)
            {
                rm.score = rm.uciScore = value;
                rm.selDepth            = thisThread->selDepth;
                rm.scoreLowerbound = rm.scoreUpperbound = false;

                if (value >= beta)
                {
                    rm.scoreLowerbound = true;
                    rm.uciScore        = beta;
                }
                else if (value <= alpha)
                {
                    rm.scoreUpperbound = true;
                    rm.uciScore        = alpha;
                }

                rm.pv.resize(1);

                assert((ss + 1)->pv);

                for (Move* m = (ss + 1)->pv; *m != Move::none(); ++m)
                    rm.pv.push_back(*m);

                // We record how often the best move has been changed in each iteration.
                // This information is used for time management. In MultiPV mode,
                // we must take care to only do this for the first PV line.
                if (moveCount > 1 && !thisThread->pvIdx)
                    ++thisThread->bestMoveChanges;
            }
            else
                // All other moves but the PV, are set to the lowest value: this
                // is not a problem when sorting because the sort is stable and the
                // move position in the list is preserved - just the PV is pushed up.
                rm.score = -VALUE_INFINITE;
        }

        // In case we have an alternative move equal in eval to the current bestmove,
        // promote it to bestmove by pretending it just exceeds alpha (but not beta).
        int inc = (value == bestValue && (int(nodes) & 15) == 0
                   && ss->ply + 2 + ss->ply / 32 >= thisThread->rootDepth
                   && std::abs(value) + 1 < VALUE_TB_WIN_IN_MAX_PLY);

        if (value + inc > bestValue)
        {
            bestValue = value;

            if (value + inc > alpha)
            {
                bestMove = move;

                if (PvNode && !rootNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value >= beta)
                {
                    ss->cutoffCnt += 1 + !ttData.move - (extension >= 2);
                    assert(value >= beta);  // Fail high
                    break;
                }
                else
                {
                    // Reduce other moves if we have found at least one score improvement (~2 Elo)
                    if (depth > 2 && depth < 13 && std::abs(value) < VALUE_TB_WIN_IN_MAX_PLY)
                        depth -= 2;

                    assert(depth > 0);
                    alpha = value;  // Update alpha! Always alpha < beta
                }
            }
        }

        // If the move is worse than some previously searched move,
        // remember it, to update its stats later.
        if (move != bestMove && moveCount <= 32)
        {
            if (capture)
                capturesSearched[captureCount++] = move;
            else
                quietsSearched[quietCount++] = move;
        }
    }

    // Step 21. Check for mate and stalemate
    // All legal moves have been searched and if there are no legal moves, it
    // must be a mate or a stalemate. If we are in a singular extension search then
    // return a fail low score.

    assert(moveCount || !ss->inCheck || excludedMove || !MoveList<LEGAL>(pos).size());

    // Adjust best value for fail high cases at non-pv nodes
    if (!PvNode && bestValue >= beta && std::abs(bestValue) < VALUE_TB_WIN_IN_MAX_PLY
        && std::abs(beta) < VALUE_TB_WIN_IN_MAX_PLY && std::abs(alpha) < VALUE_TB_WIN_IN_MAX_PLY)
        bestValue = (bestValue * depth + beta) / (depth + 1);

    if (!moveCount)
        bestValue = excludedMove ? alpha : ss->inCheck ? mated_in(ss->ply) : VALUE_DRAW;

    // If there is a move that produces search value greater than alpha we update the stats of searched moves
    else if (bestMove)
        update_all_stats(pos, ss, *this, bestMove, bestValue, beta, prevSq, quietsSearched,
                         quietCount, capturesSearched, captureCount, depth);

    // Bonus for prior countermove that caused the fail low
    else if (!priorCapture && prevSq != SQ_NONE)
    {
        int bonus = (113 * (depth > 5) + 118 * (PvNode || cutNode)
                     + 191 * ((ss - 1)->statScore < -14396) + 119 * ((ss - 1)->moveCount > 8)
                     + 64 * (!ss->inCheck && bestValue <= ss->staticEval - 107)
                     + 147 * (!(ss - 1)->inCheck && bestValue <= -(ss - 1)->staticEval - 75));
        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                      stat_bonus(depth) * bonus / 100);
        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()]
          << stat_bonus(depth) * bonus / 200;


        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << stat_bonus(depth) * bonus / 25;
    }

    if (PvNode)
        bestValue = std::min(bestValue, maxValue);

    // If no good move is found and the previous position was ttPv, then the previous
    // opponent move is probably good and the new position is added to the search tree. (~7 Elo)
    if (bestValue <= alpha)
        ss->ttPv = ss->ttPv || ((ss - 1)->ttPv && depth > 3);

    // Write gathered information in transposition table
    // Static evaluation is saved as it was before correction history
    if (!excludedMove && !(rootNode && thisThread->pvIdx))
        ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), ss->ttPv,
                       bestValue >= beta    ? BOUND_LOWER
                       : PvNode && bestMove ? BOUND_EXACT
                                            : BOUND_UPPER,
                       depth, bestMove, unadjustedStaticEval, tt.generation());

    // Adjust correction history
    if (!ss->inCheck && (!bestMove || !pos.capture(bestMove))
        && !(bestValue >= beta && bestValue <= ss->staticEval)
        && !(!bestMove && bestValue >= ss->staticEval))
    {
        auto bonus = std::clamp(int(bestValue - ss->staticEval) * depth / 8,
                                -CORRECTION_HISTORY_LIMIT / 4, CORRECTION_HISTORY_LIMIT / 4);
        thisThread->correctionHistory[us][pawn_structure_index<Correction>(pos)] << bonus;
    }

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}


// Quiescence search function, which is called by the main search function with zero depth, or
// recursively with further decreasing depth per call. With depth <= 0, we "should" be using
// static eval only, but tactical moves may confuse the static eval. To fight this horizon effect,
// we implement this qsearch of tactical moves only.
// See https://www.chessprogramming.org/Horizon_Effect and https://www.chessprogramming.org/Quiescence_Search
// (~155 Elo)
template<NodeType nodeType>
Value Search::Worker::qsearch(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth) {

    static_assert(nodeType != Root);
    constexpr bool PvNode = nodeType == PV;

    assert(alpha >= -VALUE_INFINITE && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(depth <= 0);

    // Check if we have an upcoming move that draws by repetition, or if
    // the opponent had an alternative move earlier to this position. (~1 Elo)
    if (alpha < VALUE_DRAW && pos.has_game_cycle(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    Move      pv[MAX_PLY + 1];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, bestMove;
    Value bestValue, value, futilityBase;
    bool  pvHit, givesCheck, capture;
    int   moveCount;
    Color us = pos.side_to_move();

    // Step 1. Initialize node
    if (PvNode)
    {
        (ss + 1)->pv = pv;
        ss->pv[0]    = Move::none();
    }

    Worker* thisThread = this;
    bestMove           = Move::none();
    ss->inCheck        = pos.checkers();
    moveCount          = 0;

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    // Step 2. Check for an immediate draw or maximum ply reached
    if (pos.is_draw(ss->ply) || ss->ply >= MAX_PLY)
        return (ss->ply >= MAX_PLY && !ss->inCheck)
               ? evaluate(networks[numaAccessToken], pos, refreshTable, thisThread->optimism[us])
               : VALUE_DRAW;

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    // Note that unlike regular search, which stores the literal depth into the TT, from QS we
    // only store the current movegen stage as "depth". If in check, we search all evasions and
    // thus store DEPTH_QS_CHECKS. (Evasions may be quiet, and _CHECKS includes quiets.)
    Depth qsTtDepth = ss->inCheck || depth >= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS : DEPTH_QS_NORMAL;

    // Step 3. Transposition table lookup
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = ttHit ? ttData.move : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    pvHit        = ttHit && ttData.is_pv;

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && ttData.depth >= qsTtDepth
        && ttData.value != VALUE_NONE  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER)))
        return ttData.value;

    // Step 4. Static evaluation of the position
    Value unadjustedStaticEval = VALUE_NONE;
    if (ss->inCheck)
        bestValue = futilityBase = -VALUE_INFINITE;
    else
    {
        if (ss->ttHit)
        {
            // Never assume anything about values stored in TT
            unadjustedStaticEval = ttData.eval;
            if (unadjustedStaticEval == VALUE_NONE)
                unadjustedStaticEval =
                  evaluate(networks[numaAccessToken], pos, refreshTable, thisThread->optimism[us]);
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, *thisThread, pos);

            // ttValue can be used as a better position evaluation (~13 Elo)
            if (std::abs(ttData.value) < VALUE_TB_WIN_IN_MAX_PLY
                && (ttData.bound & (ttData.value > bestValue ? BOUND_LOWER : BOUND_UPPER)))
                bestValue = ttData.value;
        }
        else
        {
            // In case of null move search, use previous static eval with a different sign
            unadjustedStaticEval =
              (ss - 1)->currentMove != Move::null()
                ? evaluate(networks[numaAccessToken], pos, refreshTable, thisThread->optimism[us])
                : -(ss - 1)->staticEval;
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, *thisThread, pos);
        }

        // Stand pat. Return immediately if static value is at least beta
        if (bestValue >= beta)
        {
            if (std::abs(bestValue) < VALUE_TB_WIN_IN_MAX_PLY && !PvNode)
                bestValue = (3 * bestValue + beta) / 4;
            if (!ss->ttHit)
                ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), false, BOUND_LOWER,
                               DEPTH_UNSEARCHED, Move::none(), unadjustedStaticEval,
                               tt.generation());
            return bestValue;
        }

        if (bestValue > alpha)
            alpha = bestValue;

        futilityBase = ss->staticEval + 294;
    }

    const PieceToHistory* contHist[] = {(ss - 1)->continuationHistory,
                                        (ss - 2)->continuationHistory};

    // Initialize a MovePicker object for the current position, and prepare to search the moves.
    // We presently use two stages of qs movegen, first captures+checks, then captures only.
    // (When in check, we simply search all evasions.)
    // (Presently, having the checks stage is worth only 1 Elo, and may be removable in the near future,
    // which would result in only a single stage of QS movegen.)
    Square     prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;
    MovePicker mp(pos, ttData.move, depth, &thisThread->mainHistory, &thisThread->captureHistory,
                  contHist, &thisThread->pawnHistory);

    // Step 5. Loop through all pseudo-legal moves until no moves remain or a beta cutoff occurs.
    while ((move = mp.next_move()) != Move::none())
    {
        assert(move.is_ok());

        // Check for legality
        if (!pos.legal(move))
            continue;

        givesCheck = pos.gives_check(move);
        capture    = pos.capture_stage(move);

        moveCount++;

        // Step 6. Pruning
        if (bestValue > VALUE_TB_LOSS_IN_MAX_PLY && pos.non_pawn_material(us))
        {
            // Futility pruning and moveCount pruning (~10 Elo)
            if (!givesCheck && move.to_sq() != prevSq && futilityBase > VALUE_TB_LOSS_IN_MAX_PLY
                && move.type_of() != PROMOTION)
            {
                if (moveCount > 2)
                    continue;

                Value futilityValue = futilityBase + PieceValue[pos.piece_on(move.to_sq())];

                // If static eval + value of piece we are going to capture is much lower
                // than alpha we can prune this move. (~2 Elo)
                if (futilityValue <= alpha)
                {
                    bestValue = std::max(bestValue, futilityValue);
                    continue;
                }

                // If static eval is much lower than alpha and move is not winning material
                // we can prune this move. (~2 Elo)
                if (futilityBase <= alpha && !pos.see_ge(move, 1))
                {
                    bestValue = std::max(bestValue, futilityBase);
                    continue;
                }

                // If static exchange evaluation is much worse than what is needed to not
                // fall below alpha we can prune this move.
                if (futilityBase > alpha && !pos.see_ge(move, (alpha - futilityBase) * 4))
                {
                    bestValue = alpha;
                    continue;
                }
            }

            // Continuation history based pruning (~3 Elo)
            if (!capture
                && (*contHist[0])[pos.moved_piece(move)][move.to_sq()]
                       + (*contHist[1])[pos.moved_piece(move)][move.to_sq()]
                       + thisThread->pawnHistory[pawn_structure_index(pos)][pos.moved_piece(move)]
                                                [move.to_sq()]
                     <= 4452)
                continue;

            // Do not search moves with bad enough SEE values (~5 Elo)
            if (!pos.see_ge(move, -74))
                continue;
        }

        // Speculative prefetch as early as possible
        prefetch(tt.first_entry(pos.key_after(move)));

        // Update the current move
        ss->currentMove = move;
        ss->continuationHistory =
          &thisThread
             ->continuationHistory[ss->inCheck][capture][pos.moved_piece(move)][move.to_sq()];

        // Step 7. Make and search the move
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);
        pos.do_move(move, st, givesCheck);
        value = -qsearch<nodeType>(pos, ss + 1, -beta, -alpha, depth - 1);
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 8. Check for a new best move
        if (value > bestValue)
        {
            bestValue = value;

            if (value > alpha)
            {
                bestMove = move;

                if (PvNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value < beta)  // Update alpha here!
                    alpha = value;
                else
                    break;  // Fail high
            }
        }
    }

    // Step 9. Check for mate
    // All legal moves have been searched. A special case: if we're in check
    // and no legal moves were found, it is checkmate.
    if (ss->inCheck && bestValue == -VALUE_INFINITE)
    {
        assert(!MoveList<LEGAL>(pos).size());
        return mated_in(ss->ply);  // Plies to mate from the root
    }

    if (std::abs(bestValue) < VALUE_TB_WIN_IN_MAX_PLY && bestValue >= beta)
        bestValue = (3 * bestValue + beta) / 4;

    // Save gathered info in transposition table
    // Static evaluation is saved as it was before adjustment by correction history
    ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), pvHit,
                   bestValue >= beta ? BOUND_LOWER : BOUND_UPPER, qsTtDepth, bestMove,
                   unadjustedStaticEval, tt.generation());

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}

Depth Search::Worker::reduction(bool i, Depth d, int mn, int delta) const {
    int reductionScale = reductions[d] * reductions[mn];
    return (reductionScale + 1236 - delta * 746 / rootDelta) / 1024 + (!i && reductionScale > 1326);
}

// elapsed() returns the time elapsed since the search started. If the
// 'nodestime' option is enabled, it will return the count of nodes searched
// instead. This function is called to check whether the search should be
// stopped based on predefined thresholds like time limits or nodes searched.
//
// elapsed_time() returns the actual time elapsed since the start of the search.
// This function is intended for use only when printing PV outputs, and not used
// for making decisions within the search algorithm itself.
TimePoint Search::Worker::elapsed() const {
    return main_manager()->tm.elapsed([this]() { return threads.nodes_searched(); });
}

TimePoint Search::Worker::elapsed_time() const { return main_manager()->tm.elapsed_time(); }


namespace {
// Adjusts a mate or TB score from "plies to mate from the root"
// to "plies to mate from the current position". Standard scores are unchanged.
// The function is called before storing a value in the transposition table.
Value value_to_tt(Value v, int ply) {

    assert(v != VALUE_NONE);
    return v >= VALUE_TB_WIN_IN_MAX_PLY ? v + ply : v <= VALUE_TB_LOSS_IN_MAX_PLY ? v - ply : v;
}


// Inverse of value_to_tt(): it adjusts a mate or TB score
// from the transposition table (which refers to the plies to mate/be mated from
// current position) to "plies to mate/be mated (TB win/loss) from the root".
// However, to avoid potentially false mate or TB scores related to the 50 moves rule
// and the graph history interaction, we return the highest non-TB score instead.
Value value_from_tt(Value v, int ply, int r50c) {

    if (v == VALUE_NONE)
        return VALUE_NONE;

    // handle TB win or better
    if (v >= VALUE_TB_WIN_IN_MAX_PLY)
    {
        // Downgrade a potentially false mate score
        if (v >= VALUE_MATE_IN_MAX_PLY && VALUE_MATE - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        return v - ply;
    }

    // handle TB loss or worse
    if (v <= VALUE_TB_LOSS_IN_MAX_PLY)
    {
        // Downgrade a potentially false mate score.
        if (v <= VALUE_MATED_IN_MAX_PLY && VALUE_MATE + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        return v + ply;
    }

    return v;
}


// Adds current move and appends child pv[]
void update_pv(Move* pv, Move move, const Move* childPv) {

    for (*pv++ = move; childPv && *childPv != Move::none();)
        *pv++ = *childPv++;
    *pv = Move::none();
}


// Updates stats at the end of search() when a bestMove is found
void update_all_stats(const Position& pos,
                      Stack*          ss,
                      Search::Worker& workerThread,
                      Move            bestMove,
                      Value           bestValue,
                      Value           beta,
                      Square          prevSq,
                      Move*           quietsSearched,
                      int             quietCount,
                      Move*           capturesSearched,
                      int             captureCount,
                      Depth           depth) {

    CapturePieceToHistory& captureHistory = workerThread.captureHistory;
    Piece                  moved_piece    = pos.moved_piece(bestMove);
    PieceType              captured;

    int quietMoveBonus = stat_bonus(depth + 1);
    int quietMoveMalus = stat_malus(depth);

    if (!pos.capture_stage(bestMove))
    {
        int bestMoveBonus = bestValue > beta + 164 ? quietMoveBonus      // larger bonus
                                                   : stat_bonus(depth);  // smaller bonus

        update_quiet_stats(pos, ss, workerThread, bestMove, bestMoveBonus);

        // Decrease stats for all non-best quiet moves
        for (int i = 0; i < quietCount; ++i)
            update_quiet_histories(pos, ss, workerThread, quietsSearched[i], -quietMoveMalus);
    }
    else
    {
        // Increase stats for the best move in case it was a capture move
        captured = type_of(pos.piece_on(bestMove.to_sq()));
        captureHistory[moved_piece][bestMove.to_sq()][captured] << quietMoveBonus;
    }

    // Extra penalty for a quiet early move that was not a TT move or
    // main killer move in previous ply when it gets refuted.
    if (prevSq != SQ_NONE
        && ((ss - 1)->moveCount == 1 + (ss - 1)->ttHit
            || ((ss - 1)->currentMove == (ss - 1)->killers[0]))
        && !pos.captured_piece())
        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq, -quietMoveMalus);

    // Decrease stats for all non-best capture moves
    for (int i = 0; i < captureCount; ++i)
    {
        moved_piece = pos.moved_piece(capturesSearched[i]);
        captured    = type_of(pos.piece_on(capturesSearched[i].to_sq()));
        captureHistory[moved_piece][capturesSearched[i].to_sq()][captured] << -quietMoveMalus;
    }
}


// Updates histories of the move pairs formed
// by moves at ply -1, -2, -3, -4, and -6 with current move.
void update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus) {

    bonus = bonus * 51 / 64;

    for (int i : {1, 2, 3, 4, 6})
    {
        // Only update the first 2 continuation histories if we are in check
        if (ss->inCheck && i > 2)
            break;
        if (((ss - i)->currentMove).is_ok())
            (*(ss - i)->continuationHistory)[pc][to] << bonus / (1 + (i == 3));
    }
}

// Updates move sorting heuristics
void update_refutations(const Position& pos, Stack* ss, Search::Worker& workerThread, Move move) {

    // Update killers
    if (ss->killers[0] != move)
    {
        ss->killers[1] = ss->killers[0];
        ss->killers[0] = move;
    }

    // Update countermove history
    if (((ss - 1)->currentMove).is_ok())
    {
        Square prevSq                                           = ((ss - 1)->currentMove).to_sq();
        workerThread.counterMoves[pos.piece_on(prevSq)][prevSq] = move;
    }
}

void update_quiet_histories(
  const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus) {

    Color us = pos.side_to_move();
    workerThread.mainHistory[us][move.from_to()] << bonus;

    update_continuation_histories(ss, pos.moved_piece(move), move.to_sq(), bonus);

    int pIndex = pawn_structure_index(pos);
    workerThread.pawnHistory[pIndex][pos.moved_piece(move)][move.to_sq()] << bonus / 2;
}

// Updates move sorting heuristics
void update_quiet_stats(
  const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus) {

    update_refutations(pos, ss, workerThread, move);
    update_quiet_histories(pos, ss, workerThread, move, bonus);
}

}

// When playing with strength handicap, choose the best move among a set of RootMoves
// using a statistical rule dependent on 'level'. Idea by Heinz van Saanen.
Move Skill::pick_best(const RootMoves& rootMoves, size_t multiPV) {
    static PRNG rng(now());  // PRNG sequence should be non-deterministic

    // RootMoves are already sorted by score in descending order
    Value  topScore = rootMoves[0].score;
    int    delta    = std::min(topScore - rootMoves[multiPV - 1].score, int(PawnValue));
    int    maxScore = -VALUE_INFINITE;
    double weakness = 120 - 2 * level;

    // Choose best move. For each move score we add two terms, both dependent on
    // weakness. One is deterministic and bigger for weaker levels, and one is
    // random. Then we choose the move with the resulting highest score.
    for (size_t i = 0; i < multiPV; ++i)
    {
        // This is our magic formula
        int push = (weakness * int(topScore - rootMoves[i].score)
                    + delta * (rng.rand<unsigned>() % int(weakness)))
                 / 128;

        if (rootMoves[i].score + push >= maxScore)
        {
            maxScore = rootMoves[i].score + push;
            best     = rootMoves[i].pv[0];
        }
    }

    return best;
}


// Used to print debug info and, more importantly,
// to detect when we are out of available time and thus stop the search.
void SearchManager::check_time(Search::Worker& worker) {
    if (--callsCnt > 0)
        return;

    // When using nodes, ensure checking rate is not lower than 0.1% of nodes
    callsCnt = worker.limits.nodes ? std::min(512, int(worker.limits.nodes / 1024)) : 512;

    static TimePoint lastInfoTime = now();

    TimePoint elapsed = tm.elapsed([&worker]() { return worker.threads.nodes_searched(); });
    TimePoint tick    = worker.limits.startTime + elapsed;

    if (tick - lastInfoTime >= 1000)
    {
        lastInfoTime = tick;
        dbg_print();
    }

    // We should not stop pondering until told so by the GUI
    if (ponder)
        return;

    if (
      // Later we rely on the fact that we can at least use the mainthread previous
      // root-search score and PV in a multithreaded environment to prove mated-in scores.
      worker.completedDepth >= 1
      && ((worker.limits.use_time_management() && (elapsed > tm.maximum() || stopOnPonderhit))
          || (worker.limits.movetime && elapsed >= worker.limits.movetime)
          || (worker.limits.nodes && worker.threads.nodes_searched() >= worker.limits.nodes)))
        worker.threads.stop = worker.threads.abortedSearch = true;
}

void SearchManager::pv(const Search::Worker&     worker,
                       const ThreadPool&         threads,
                       const TranspositionTable& tt,
                       Depth                     depth) const {

    const auto  nodes     = threads.nodes_searched();
    const auto& rootMoves = worker.rootMoves;
    const auto& pos       = worker.rootPos;
    size_t      pvIdx     = worker.pvIdx;
    TimePoint   time      = tm.elapsed_time() + 1;
    size_t      multiPV   = std::min(size_t(worker.options["MultiPV"]), rootMoves.size());
    uint64_t    tbHits    = threads.tb_hits() + (worker.tbConfig.rootInTB ? rootMoves.size() : 0);

    for (size_t i = 0; i < multiPV; ++i)
    {
        bool updated = rootMoves[i].score != -VALUE_INFINITE;

        if (depth == 1 && !updated && i > 0)
            continue;

        Depth d = updated ? depth : std::max(1, depth - 1);
        Value v = updated ? rootMoves[i].uciScore : rootMoves[i].previousScore;

        if (v == -VALUE_INFINITE)
            v = VALUE_ZERO;

        bool tb = worker.tbConfig.rootInTB && std::abs(v) <= VALUE_TB;
        v       = tb ? rootMoves[i].tbScore : v;

        std::string pv;
        for (Move m : rootMoves[i].pv)
            pv += UCIEngine::move(m, pos.is_chess960()) + " ";

        // remove last whitespace
        if (!pv.empty())
            pv.pop_back();

        auto wdl   = worker.options["UCI_ShowWDL"] ? UCIEngine::wdl(v, pos) : "";
        auto bound = rootMoves[i].scoreLowerbound
                     ? "lowerbound"
                     : (rootMoves[i].scoreUpperbound ? "upperbound" : "");

        InfoFull info;

        info.depth    = d;
        info.selDepth = rootMoves[i].selDepth;
        info.multiPV  = i + 1;
        info.score    = {v, pos};
        info.wdl      = wdl;

        if (i == pvIdx && !tb && updated)  // tablebase- and previous-scores are exact
            info.bound = bound;

        info.timeMs   = time;
        info.nodes    = nodes;
        info.nps      = nodes * 1000 / time;
        info.tbHits   = tbHits;
        info.pv       = pv;
        info.hashfull = tt.hashfull();

        updates.onUpdateFull(info);
    }
}

// Called in case we have no ponder move before exiting the search,
// for instance, in case we stop the search during a fail high at root.
// We try hard to have a ponder move to return to the GUI,
// otherwise in case of 'ponder on' we have nothing to think about.
bool RootMove::extract_ponder_from_tt(const TranspositionTable& tt, Position& pos) {

    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    assert(pv.size() == 1);
    if (pv[0] == Move::none())
        return false;

    pos.do_move(pv[0], st);

    auto [ttHit, ttData, ttWriter] = tt.probe(pos.key());
    if (ttHit)
    {
        if (MoveList<LEGAL>(pos).contains(ttData.move))
            pv.push_back(ttData.move);
    }

    pos.undo_move(pv[0]);
    return pv.size() > 1;
}


}  // namespace Stockfish
